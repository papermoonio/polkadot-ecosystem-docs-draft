{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Polkadot Draft Ecosystem Documentation","text":"<p>Welcome to a draft documentation site for ecosystem-related things on Polkadot, a scalable, interoperable, and secure network empowering the next generation of web builders. This site aims to serve as a central knowledge exchange for teams across the Polkadot ecosystem.</p> <p>Here's what you'll be able to find in the documentation:</p> <ul> <li>A deep dive into Polkadot - Get familiar with Polkadot's architecture, inner workings, and core technologies, including Agile Coretime, XCM, bridges, governance, and more</li> <li>Resources for parachain development - Learn how to create, test, and deploy a parachain from scratch using Substrate and explore how to build and customize your runtime, including adding pallets and implementing custom logic</li> <li>Parachain tooling - Access specialized tools and frameworks to streamline parachain development, from launch to maintenance</li> <li>Documentation on smart contract development - Find resources and tutorials on developing, testing, and deploying smart contracts using Solidity and ink! on Polkadot's EVM and other supported EVM environments in the ecosystem</li> <li>Ecosystem tooling - Discover a suite of powerful tools, including SDKs, APIs, and other resources, to build scalable, interoperable applications on Polkadot</li> <li>Information on running infrastructure - Infrastructure providers can find detailed information on operating and maintaining validator nodes, including block production, transaction validation, and ensuring network security</li> </ul> <p>These resources provide practical benefits and best practices for working with smart contracts, pallets, and Substrate and offer guidance for those building tooling and running infrastructure.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/","title":"Asset Conversion on Asset Hub","text":""},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#introduction","title":"Introduction","text":"<p>Asset Conversion is an Automated Market Maker (AMM) utilizing Uniswap V2 logic and implemented as a pallet on Polkadot's Asset Hub. For more details about this feature, please visit the Asset Conversion on Asset Hub wiki page. </p> <p>This guide will provide detailed information about the key functionalities offered by the Asset Conversion pallet on Asset Hub, including: </p> <ul> <li>Creating a liquidity pool</li> <li>Adding liquidity to a pool</li> <li>Swapping assets</li> <li>Withdrawing liquidity from a pool</li> </ul>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#prerequisites","title":"Prerequisites","text":"<p>Before converting assets on Asset Hub, you must ensure you have:</p> <ul> <li>Access to the Polkadot.js Apps interface and a connection with the intended blockchain</li> <li>A funded wallet containing the assets you wish to convert and enough available funds to cover the transaction fees</li> <li>An asset registered on Asset Hub that you want to convert. If you haven't created an asset on Asset Hub yet, refer to the Register a Local Asset or Register a Foreign Asset documentation to create an asset.</li> </ul>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#creating-a-liquidity-pool","title":"Creating a Liquidity Pool","text":"<p>If an asset on Asset Hub does not have an existing liquidity pool, the first step is to create one. </p> <p>The asset conversion pallet provides the <code>createPool</code> extrinsic to create a new liquidity pool, creating an empty liquidity pool and a new <code>LP token</code> asset. </p> <p>Note</p> <p>A testing token with the asset ID <code>1112</code> and the name <code>PPM</code> was created for this example.</p> <p>As stated in the Test Environment Setup section, this tutorial is based on the assumption that you have an instance of Polkadot Asset Hub running locally. Therefore, the demo liquidity pool will be created between DOT and PPM tokens. However, the same steps can be applied to any other asset on Asset Hub.</p> <p>From the Asset Hub perspective, the Multilocation that identifies the PPM token is the following:</p> <pre><code>{\n   parents: 0,\n   interior: {\n     X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n   }\n}\n</code></pre> <p>Note</p> <p>The <code>PalletInstance</code> value of <code>50</code> represents the Assets pallet on Asset Hub. The <code>GeneralIndex</code> value of <code>1112</code> is the PPM asset's Asset ID.</p> <p>To create the liquidity pool, you can follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.Js App interface</p> <ol> <li>Select Developer from the top menu</li> <li> <p>Click on Extrinsics from the dropdown menu</p> <p></p> </li> </ol> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>createPool</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet </li> <li> <p>Choose the <code>createPool</code> extrinsic from the list of available extrinsics</p> <p></p> </li> </ol> </li> <li> <p>Fill in the required fields:</p> <ol> <li><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:      <pre><code>{\n   parents: 0,\n   interior: Here\n}\n</code></pre></li> <li><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies: <pre><code>{\n   parents: 0,\n   interior: {\n     X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n   }\n}\n</code></pre></li> <li> <p>Click on Submit Transaction to create the liquidity pool</p> <p></p> </li> </ol> </li> </ol> <p>Signing and submitting the transaction triggers the creation of the liquidity pool. To verify the new pool's creation, check the Explorer section on the Polkadot.Js App interface and ensure that the <code>PoolCreated</code> event was emitted.</p> <p></p> <p>As the preceding image shows, the <code>lpToken</code> ID created for this pool is 19. This ID is essential to identify the liquidity pool and associated LP tokens.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#adding-liquidity-to-a-pool","title":"Adding Liquidity to a Pool","text":"<p>The <code>addLiquidity</code> extrinsic allows users to provide liquidity to a pool of two assets. Users specify their preferred amounts for both assets and minimum acceptable quantities. The function determines the best asset contribution, which may vary from the amounts desired but won't fall below the specified minimums. Providers receive liquidity tokens representing their pool portion in return for their contribution.</p> <p>To add liquidity to a pool, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.Js App interface</p> <ol> <li>Select Developer from the top menu</li> <li> <p>Click on Extrinsics from the dropdown menu</p> <p></p> </li> </ol> </li> <li> <p>Choose the <code>assetConversion</code> pallet and click on the <code>addLiquidity</code> extrinsic</p> <ol> <li>Select the <code>assetConversion</code> pallet</li> <li> <p>Choose the <code>addLiquidity</code> extrinsic from the list of available extrinsics</p> <p></p> </li> </ol> </li> <li> <p>Fill in the required fields:</p> <ol> <li><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:      <pre><code>{\n   parents: 0,\n   interior: Here\n}\n</code></pre></li> <li><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies: <pre><code>{\n   parents: 0,\n   interior: {\n     X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n   }\n}\n</code></pre></li> <li><code>amount1Desired</code> - the amount of the first asset that will be contributed to the pool</li> <li><code>amount2Desired</code> - the quantity of the second asset intended for pool contribution</li> <li><code>amount1Min</code> - the minimum amount of the first asset that will be contributed</li> <li><code>amount2Min</code> - the lowest acceptable quantity of the second asset for contribution</li> <li><code>mintTo</code> - the account to which the liquidity tokens will be minted</li> <li> <p>Click on Submit Transaction to add liquidity to the pool</p> <p></p> <p>Warning</p> <p>Ensure that the appropriate amount of tokens provided has been minted previously and is available in your account before adding liquidity to the pool.</p> <p>In this case, the liquidity provided to the pool is between DOT tokens and PPM tokens with the asset ID 1112 on Polkadot Asset Hub. The intention is to provide liquidity for 1 DOT token (<code>u128</code> value of 1000000000000 as it has ten decimals) and 1 PPM token (<code>u128</code> value of 1000000000000 as it also has ten decimals).</p> </li> </ol> </li> </ol> <p>Signing and submitting the transaction adds liquidity to the pool. To verify the liquidity addition, check the Explorer section on the Polkadot.Js App interface and ensure that the <code>LiquidityAdded</code> event was emitted.</p> <p></p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#swapping-assets","title":"Swapping Assets","text":""},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#swapping-from-an-exact-amount-of-tokens","title":"Swapping From an Exact Amount of Tokens","text":"<p>The asset conversion pallet enables users to exchange a specific quantity of one asset for another in a designated liquidity pool by swapping them for an exact amount of tokens. It guarantees the user will receive at least a predetermined minimum amount of the second asset. This function increases trading predictability and allows users to conduct asset exchanges with confidence that they are assured a minimum return.</p> <p>To swap assets for an exact amount of tokens, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.Js App interface</p> <ol> <li>Select Developer from the top menu</li> <li> <p>Click on Extrinsics from the dropdown menu</p> <p></p> </li> </ol> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>swapExactTokensForTokens</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li> <p>Choose the <code>swapExactTokensForTokens</code> extrinsic from the list of available extrinsics</p> <p></p> </li> </ol> </li> <li> <p>Fill in the required fields:</p> <ol> <li><code>path:Vec&lt;StagingXcmV3MultiLocation\\&gt;</code> - an array of Multilocations representing the path of the swap. The first and last elements of the array are the input and output assets, respectively. In this case, the path consists of two elements:<ul> <li><code>0: StagingXcmV3MultiLocation</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:  <pre><code>{\n   parents: 0,\n   interior: Here\n}\n</code></pre></li> <li><code>1: StagingXcmV3MultiLocation</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies: <pre><code>{\n    parents: 0,\n    interior: {\n        X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n    }\n}\n</code></pre></li> </ul> </li> <li><code>amountOut</code> - the exact amount of the second asset that the user wants to receive</li> <li><code>amountInMax</code> - the maximum amount of the first asset that the user is willing to swap</li> <li><code>sendTo</code> - the account to which the swapped assets will be sent</li> <li><code>keepAlive</code> - a boolean value that determines whether the pool should be kept alive after the swap</li> <li> <p>Click on Submit Transaction to swap assets for an exact amount of tokens</p> <p></p> <p>Warning</p> <p>Ensure that the appropriate amount of tokens provided has been minted previously and is available in your account before adding liquidity to the pool.</p> <p>In this case, the intention is to swap 0.01 DOT token (u128 value of 100000000000 as it has ten decimals) for 0.04 PPM token (u128 value of 400000000000 as it also has ten decimals).</p> </li> </ol> </li> </ol> <p>Signing and submitting the transaction will execute the swap. To verify execution, check the Explorer section on the Polkadot.Js App interface and make sure that the <code>SwapExecuted</code> event was emitted.</p> <p></p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#swapping-to-an-exact-amount-of-tokens","title":"Swapping To an Exact Amount of Tokens","text":"<p>Conversely, the Asset Conversion pallet comes with a function that allows users to trade a variable amount of one asset to acquire a precise quantity of another. It ensures that users stay within a set maximum of the initial asset to obtain the desired amount of the second asset. This provides a method to control transaction costs while achieving the intended result.</p> <p>To swap assets for an exact amount of tokens, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.Js App interface</p> <ol> <li>Select Developer from the top menu</li> <li> <p>Click on Extrinsics from the dropdown menu</p> <p></p> </li> </ol> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>swapTokensForExactTokens</code> extrinsic:</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li> <p>Choose the <code>swapTokensForExactTokens</code> extrinsic from the list of available extrinsics</p> <p></p> </li> </ol> </li> <li> <p>Fill in the required fields:</p> <ol> <li><code>path:Vec&lt;StagingXcmV3MultiLocation\\&gt;</code> - an array of Multilocations representing the path of the swap. The first and last elements of the array are the input and output assets, respectively. In this case, the path consists of two elements:<ul> <li><code>0: StagingXcmV3MultiLocation</code> - the Multilocation of the first asset in the pool. In this case, it is the PPM token, which the following Multilocation represents: <pre><code>{\n    parents: 0,\n    interior: {\n        X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n    }\n}\n</code></pre></li> <li>1: StagingXcmV3MultiLocation - the second asset's Multilocation within the pool. This refers to the DOT token, which the following Multilocation identifies:   <pre><code>{\n   parents: 0,\n   interior: Here\n}\n</code></pre></li> </ul> </li> <li><code>amountOut</code> - the exact amount of the second asset that the user wants to receive</li> <li><code>amountInMax</code> - the maximum amount of the first asset that the user is willing to swap</li> <li><code>sendTo</code> - the account to which the swapped assets will be sent</li> <li><code>keepAlive</code> - a boolean value that determines whether the pool should be kept alive after the swap</li> <li> <p>Click on Submit Transaction to swap assets for an exact amount of tokens</p> <p></p> <p>Warning</p> <p>Before swapping assets, ensure that the tokens provided have been minted previously and are available in your account.</p> <p>In this case, the intention is to swap 0.01 DOT token (<code>u128</code> value of 100000000000 as it has ten decimals) for 0.04 PPM token (<code>u128</code> value of 400000000000 as it also has ten decimals).</p> </li> </ol> </li> </ol> <p>Signing and submitting the transaction will execute the swap. To verify execution, check the Explorer section on the Polkadot.Js App interface and make sure that the <code>SwapExecuted</code> event was emitted.</p> <p></p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#withdrawing-liquidity-from-a-pool","title":"Withdrawing Liquidity from a Pool","text":"<p>The Asset Conversion pallet provides the <code>removeLiquidity</code> extrinsic to remove liquidity from a pool. This function allows users to withdraw the liquidity they offered from a pool, returning the original assets. When calling this function, users specify the number of liquidity tokens (representing their share in the pool) they wish to burn. They also set minimum acceptable amounts for the assets they expect to receive back. This mechanism ensures that users can control the minimum value they receive, protecting against unfavorable price movements during the withdrawal process.</p> <p>To withdraw liquidity from a pool, follow these steps:</p> <ol> <li> <p>Navigate to the Extrinsics section on the Polkadot.Js App interface</p> <ol> <li>Select Developer from the top menu</li> <li> <p>Click on Extrinsics from the dropdown menu</p> <p></p> </li> </ol> </li> <li> <p>Choose the <code>AssetConversion</code> pallet and click on the <code>remove_liquidity</code> extrinsic</p> <ol> <li>Select the <code>AssetConversion</code> pallet</li> <li> <p>Choose the <code>removeLiquidity</code> extrinsic from the list of available extrinsics</p> <p></p> </li> </ol> </li> <li> <p>Fill in the required fields:</p> <ol> <li><code>asset1</code> - the Multilocation of the first asset in the pool. In this case, it is the DOT token, which the following Multilocation represents:      <pre><code>{\n   parents: 0,\n   interior: Here\n}\n</code></pre></li> <li><code>asset2</code> - the second asset's Multilocation within the pool. This refers to the PPM token, which the following Multilocation identifies: <pre><code>{\n   parents: 0,\n   interior: {\n     X2: [{PalletInstance: 50}, {GeneralIndex: 1112}]\n   }\n}\n</code></pre></li> <li><code>lpTokenBurn</code> - the number of liquidity tokens to burn</li> <li><code>amount1MinReceived</code> - the minimum amount of the first asset that the user expects to receive</li> <li><code>amount2MinReceived</code> - the minimum quantity of the second asset the user expects to receive</li> <li><code>withdrawTo</code> - the account to which the withdrawn assets will be sent</li> <li> <p>Click on Submit Transaction to withdraw liquidity from the pool</p> <p></p> <p>Warning</p> <p>Ensure that the tokens provided have been minted previously and are available in your account before withdrawing liquidity from the pool.</p> <p>In this case, the intention is to withdraw 0.05 liquidity tokens from the pool, expecting to receive 0.004 DOT token (<code>u128</code> value of 40000000000 as it has ten decimals) and 0.04 PPM token (<code>u128</code> value of 400000000000 as it also has ten decimals).</p> </li> </ol> </li> </ol> <p>Signing and submitting the transaction will initiate the withdrawal of liquidity from the pool. To verify the withdrawal, check the Explorer section on the Polkadot.Js App interface and ensure that the <code>LiquidityRemoved</code> event was emitted.</p> <p></p>"},{"location":"build-on-polkadot/parachains/asset-hub/asset-conversion/#test-environment-setup","title":"Test Environment Setup","text":"<p>To test the Asset Conversion pallet, you can set up a local test environment to simulate different scenarios. This guide uses Chopsticks to spin up an instance of Polkadot Asset Hub. For further details on using Chopsticks, please refer to the Chopsticks documentation.</p> <p>To set up a local test environment, execute the following command:</p> <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml\n</code></pre> <p>Note</p> <p>This command initiates a lazy fork of Polkadot Asset Hub, including the most recent block information from the network. For Kusama Asset Hub testing, simply switch out <code>polkadot-asset-hub.yml</code> with <code>kusama-asset-hub.yml</code> in the command.</p> <p>You now have a local Asset Hub instance up and running, ready for you to test various asset conversion procedures. The process here mirrors what you'd do on MainNet. After completing a transaction on TestNet, you can apply the same steps to convert assets on MainNet.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/overview/","title":"Asset Hub","text":""},{"location":"build-on-polkadot/parachains/asset-hub/overview/#introduction","title":"Introduction","text":"<p>Asset Hub is a System Parachain designed to manage and operate assets within the Polkadot network. It specializes in creating, managing, and using assets. It is considered the primary hub for asset operations in the network. </p> <p>The native token for the Polkadot Asset Hub is DOT, and for the Kusama Asset Hub, it is KSM. Both cases maintain a trusted relationship with the relay chain.</p> <p>You can refer to the How to Teleport DOT or KSM to Asset Hub guide to learn how to send native assets to Asset Hub.</p> <p>Some common use cases for Asset Hub include:</p> <ul> <li>Creating and managing assets</li> <li>Transferring non-native tokens and creating NFTs</li> <li>Reducing transfer fees and existential deposits</li> <li>Meeting the existential deposit requirement for insufficient assets</li> </ul>"},{"location":"build-on-polkadot/parachains/asset-hub/overview/#assets","title":"Assets","text":"<p>An asset on the blockchain is a digital representation of value, such as cryptocurrencies and tokens, that can be transferred and traded. Asset Hub stores assets as a map from an ID to information about the asset, including details about the management team, total supply, and other relevant information. </p> <p>The Asset Pallet facilitates the management of these assets by providing essential functions for handling them.</p> <p>Asset Hub acts as a management portal for asset creators, letting them mint and burn tokens and get an overview of the total issuance across the Polkadot network, including tokens sent elsewhere in the network.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/overview/#local-assets","title":"Local Assets","text":"<p>Instead of using custom contracts for each asset, Asset Hub incorporates built-in asset logic, treating them as primary primitives. All assets have identical functionality.</p> <p>These assets, identified by claimable, integer-based asset IDs, are known as <code>local assets</code>. This approach simplifies asset management, as users can interact with them using the same set of functions.</p> <p>The protocol ensures that each asset ID (an integer) is unique, enabling creators to assign metadata such as the asset symbol. Therefore, users should verify their assets to confirm they possess the correct ID. For instance, although anyone can label their asset as USDT, users will probably seek the one issued by Tether (asset ID 1984).</p> <p>You can read the What is Asset Hub and How Do I Use it? article for more information on verifying an asset's legitimacy on Asset Hub.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/overview/#foreign-assets","title":"Foreign Assets","text":"<p>Asset Hub considers assets originating from a different blockchain to be foreign assets. These assets can be native tokens from various parachains or other consensus systems like Ethereum. Once a foreign asset is added to Asset Hub, users can transfer this token from its original blockchain to Asset Hub and utilize it like any other asset.</p> <p>A significant difference lies in the method used for their identification. Unlike the Assets pallet, foreign assets use XCM Multilocation instead of integers to identify assets, making asset identification much more versatile.</p> <p>Foreign assets are implemented as an instance of Assets pallet, but with a specialized configuration that enables support for XCM operations.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/","title":"Register a Foreign Asset on Asset Hub","text":""},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#introduction","title":"Introduction","text":"<p>As outlined in the Asset Hub Overview, Asset Hub supports two categories of assets: local and foreign. Local assets are created on the Asset Hub system parachain and are identified by integer IDs. On the other hand, foreign assets, which originate outside of Asset Hub, are recognized by Multilocations.</p> <p>When registering a foreign asset on Asset Hub, it's essential to notice that the process involves communication between two parachains. The Asset Hub parachain will be the destination of the foreign asset, while the source parachain will be the origin of the asset. The communication between the two parachains is facilitated by the Cross-Chain Message Passing (XCMP) protocol.</p> <p>This guide will take you through the process of registering a foreign asset on the Asset Hub parachain.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#prerequisites","title":"Prerequisites","text":"<p>The Asset Hub parachain is one of the system parachains on a relay chain, such as Polkadot or Kusama. To interact with these parachains, you can use the Polkadot.js Apps interface for:</p> <ul> <li>Polkadot Asset Hub</li> <li>Kusama Asset Hub</li> </ul> <p>For testing purposes, you can also interact with the Asset Hub instance on the following test networks:</p> <ul> <li>Rococo Asset Hub</li> <li>Paseo Asset Hub</li> </ul> <p>Before you start, ensure that you have: </p> <ul> <li>Access to the Polkadot.js Apps interface, and you are connected to the desired chain</li> <li>A parachain that supports the XCMP protocol to interact with the Asset Hub parachain</li> <li>A funded wallet to pay for the transaction fees and subsequent registration of the foreign asset</li> </ul> <p>This guide will use Polkadot, its local Asset Hub instance, and the Astar parachain (<code>ID</code> 2006), as stated in the Test Environment Setup section. However, the process is the same for other relay chains and their respective Asset Hub parachain, regardless of the network you are using and the parachain owner of the foreign asset.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#steps-to-register-a-foreign-asset","title":"Steps to Register a Foreign Asset","text":""},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#asset-hub","title":"Asset Hub","text":"<ol> <li> <p>Open the Polkadot.js Apps interface and connect to the Asset Hub parachain using the network selector in the top left corner </p> <ul> <li>Testing foreign asset registration is recommended on TestNet before proceeding to MainNet. If you haven't set up a local testing environment yet, consult the Environment setup guide. After setting up, connect to the Local Node (Chopsticks) at <code>ws://127.0.0.1:8000</code></li> <li>For live network operations, connect to the Asset Hub parachain. You can choose either Polkadot or Kusama Asset Hub from the dropdown menu, selecting your preferred RPC provider.</li> </ul> </li> <li> <p>Navigate to the Extrinsics page</p> <ol> <li>Click on the Developer tab from the top navigation bar</li> <li>Select Extrinsics from the dropdown</li> </ol> <p></p> </li> <li> <p>Select the Foreign Assets pallet</p> <ol> <li>Select the <code>foreignAssets</code> pallet from the dropdown list</li> <li>Choose the <code>create</code> extrinsic</li> </ol> <p></p> </li> <li> <p>Fill out the required fields and click on the copy icon to copy the encoded call data to your clipboard. The fields to be filled are:</p> <ul> <li> <p>id - as this is a foreign asset, the ID will be represented by a Multilocation that reflects its origin. For this case, the Multilocation of the asset will be from the source parachain perspective:</p> <pre><code>MultiLocation {parents: 1, interior: X1(Parachain(2006))};\n</code></pre> </li> <li> <p>admin - refers to the account that will be the admin of this asset. This account will be able to manage the asset, including updating its metadata. As the registered asset corresponds to a native asset of the source parachain, the admin account should be the sovereign account of the source parachain</p> Obtain the sovereign account <p>The sovereign account can be obtained through Substrate Utilities.</p> <p>Ensure that Sibling is selected and that the Para ID corresponds to the source parachain. In this case, since the guide follows the test setup stated in the Test Environment Setup section, the Para ID is <code>2006</code>.</p> <p></p> </li> <li> <p><code>minBalance</code> - the minimum balance required to hold this asset</p> </li> </ul> <p></p> Encoded call data <p>If you want an example of the encoded call data, you can copy the following: <pre><code>0x3500010100591f007369626cd6070000000000000000000000000000000000000000000000000000a0860100000000000000000000000000\n</code></pre></p> </li> </ol>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#source-parachain","title":"Source Parachain","text":"<ol> <li>Navigate to the Developer &gt; Extrinsics section</li> <li> <p>Create the extrinsic to register the foreign asset through XCM</p> <ol> <li>Paste the encoded call data copied in the previous step</li> <li>Click the Submit Transaction button</li> </ol> <p></p> <p>This XCM call involves withdrawing DOT from the sibling account of the parachain, using it to initiate an execution. The transaction will be carried out with XCM as the origin kind, and will be a hex-encoded call to create a foreign asset on Asset Hub for the specified parachain asset multilocation. Any surplus will be refunded, and the asset will be deposited into the sibling account.</p> <p>Warning</p> <p>Note that the sovereign account on the Asset Hub parachain must have a sufficient balance to cover the XCM <code>BuyExecution</code> instruction. If the account does not have enough balance, the transaction will fail.</p> Example of the encoded call data <p>If you want to have the whole XCM call ready to be copied, go to the Developer &gt; Extrinsics &gt; Decode section and paste the following hex-encoded call data: <pre><code>0x6300330003010100a10f030c000400010000070010a5d4e81300010000070010a5d4e80006030700b4f13501419ce03500010100591f007369626cd607000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n</code></pre></p> <p>Ensure to replace the encoded call data with the one you copied in the previous step.</p> </li> </ol> <p>After the transaction is successfully executed, the foreign asset will be registered on the Asset Hub parachain. </p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#asset-registration-verification","title":"Asset Registration Verification","text":"<p>To confirm that a foreign asset has been successfully accepted and registered on the Asset Hub parachain, you can navigate to the <code>Network &gt; Explorer</code> section of the Polkadot.js Apps interface for Asset Hub. You should be able to see an event that includes the following details:</p> <p></p> <p>In the image above, the success field indicates whether the asset registration was successful.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-foreign-asset/#test-environment-setup","title":"Test Environment Setup","text":"<p>To test the foreign asset registration process before deploying it on a live network, you can set up a local parachain environment. This guide uses Chopsticks to simulate that process. For more information on using Chopsticks, please refer to the Chopsticks documentation.</p> <p>To set up a test environment, run the following command:</p> <pre><code>npx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p polkadot-asset-hub \\\n--p astar\n</code></pre> <p>Note</p> <p>The above command will create a lazy fork of Polkadot as the relay chain, its Asset Hub instance, and the Astar parachain. The <code>xcm</code> parameter enables communication through the XCMP protocol between the relay chain and the parachains, allowing the registration of foreign assets on Asset Hub. For further information on the chopsticks usage of the XCMP protocol, refer to the XCM Testing section of the Chopsticks documentation.</p> <p>After executing the command, the terminal will display the subsequent output:</p> npx @acala-network/chopsticks xcm \\     --r polkadot \\     --p polkadot-asset-hub \\     --p astar  [08:20:18.905] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml     app: \"chopsticks\" [08:20:23.467] INFO: Polkadot Asset Hub RPC listening on port 8000     app: \"chopsticks\"     app: \"chopsticks\" [08:20:23.467] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/astar.yml     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata [08:20:27.936] INFO: Astar RPC listening on port 8001     app: \"chopsticks\" [08:20:28.956] INFO (xcm): Connected parachains [1000,2006]     app: \"chopsticks\" [08:20:28.957] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata         chopsticks::executor  TRACE: Completed Metadata_metadata [08:20:39.342] INFO: Polkadot RPC listening on port 8002     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata         chopsticks::executor  TRACE: Completed Metadata_metadata         chopsticks::executor  TRACE: Calling BabeApi_configuration [08:20:50.231] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Polkadot Asset Hub'     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling BabeApi_configuration         chopsticks::executor  TRACE: Completed BabeApi_configuration  <p>According to the output, the Polkadot relay chain, the Polkadot Asset Hub, and the Astar parachain are running locally and connected through XCM. They can be accessed via the Polkadot.js Apps interface:</p> <ul> <li>Polkadot Relay Chain</li> <li>Polkadot Asset Hub</li> <li>Astar Parachain</li> </ul>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/","title":"Register a Local Asset on Asset Hub","text":""},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/#introduction","title":"Introduction","text":"<p>As detailed in the Asset Hub Overview page, Asset Hub accommodates two types of assets: local and foreign. Local assets are those that were created in Asset Hub and are identifiable by an integer ID. On the other hand, foreign assets originate from a sibling parachain and are identified by a Multilocation.</p> <p>This guide will take you through the steps of registering a local asset on the Asset Hub parachain.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have access to the Polkadot.js Apps interface and a funded wallet with DOT or KSM.</p> <ul> <li>For Polkadot Asset Hub, you would need a deposit of 10 DOT and around 0.201 DOT for the metadata</li> <li>For Kusama Asset Hub, the deposit is 0.1 KSM and around 0.000669 KSM for the metadata</li> </ul> <p>You need to ensure that your Asset Hub account balance is a bit more than the sum of those two deposits, which should seamlessly account for the required deposits and transaction fees.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/#steps-to-register-a-local-asset","title":"Steps to Register a Local Asset","text":"<p>To register a local asset on the Asset Hub parachain, follow these steps:</p> <ol> <li> <p>Open the Polkadot.js Apps interface and connect to the Asset Hub parachain using the network selector in the top left corner </p> <ul> <li>You may prefer to test local asset registration on TestNet before registering the asset on a MainNet hub. If you still need to set up a local testing environment, review the Environment setup section for instructions. Once the local environment is set up, connect to the Local Node (Chopsticks) available on <code>ws://127.0.0.1:8000</code></li> <li>For the live network, connect to the <code>Asset Hub</code> parachain. Either Polkadot or Kusama Asset Hub can be selected from the dropdown list, choosing the desired RPC provider</li> </ul> </li> <li> <p>Click on the Network tab on the top navigation bar and select Assets from the dropdown list</p> <p></p> </li> <li> <p>Now, you need to examine all the registered asset IDs. This step is crucial to ensure that the asset ID you are about to register is unique. Asset IDs are displayed in the assets column</p> <p></p> </li> <li> <p>Once you have confirmed that the asset ID is unique, click on the Create button on the top right corner of the page</p> <p></p> </li> <li> <p>Fill in the required fields in the Create Asset form:</p> <ol> <li>creator account - the account to be used for creating this asset and setting up the initial metadata</li> <li>asset name - the descriptive name of the asset you are registering</li> <li>asset symbol - the symbol that will be used to represent the asset</li> <li>asset decimals - the number of decimal places for this token, with a maximum of 20 allowed through the user interface</li> <li>minimum balance - the minimum balance for the asset. This is specified in the units and decimals as requested</li> <li>asset ID - the selected id for the asset. This should not match an already-existing asset id</li> <li>Click on the Next button</li> </ol> <p></p> </li> <li> <p>Choose the accounts for the roles listed below:</p> <ol> <li>admin account - the account designated for continuous administration of the token      </li> <li>issuer account - the account that will be used for issuing this token</li> <li>freezer account - the account that will be used for performing token freezing operations</li> <li>Click on the Create button</li> </ol> <p></p> </li> <li> <p>Click on the Sign and Submit button to complete the asset registration process</p> <p></p> </li> </ol>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/#verify-asset-registration","title":"Verify Asset Registration","text":"<p>After completing these steps, the asset will be successfully registered. You can now view your asset listed on the Assets section of the Polkadot.js Apps interface.</p> <p></p> <p>Note</p> <p>Take into consideration that the Assets section\u2019s link may differ depending on the network you are using. For the local environment, the link will be <code>ws://127.0.0.1:8000/#/assets</code>.</p> <p>In this way, you have successfully registered a local asset on the Asset Hub parachain.</p> <p>For an in-depth explanation of Asset Hub and its features, please refer to the Polkadot Wiki page on Asset Hub.</p>"},{"location":"build-on-polkadot/parachains/asset-hub/register-a-local-asset/#test-setup-environment","title":"Test Setup Environment","text":"<p>You can set up a local parachain environment to test the asset registration process before deploying it on the live network. This guide uses <code>chopsticks</code> to simulate that process. For further information on chopsticks usage, refer to the Chopsticks documentation.</p> <p>To set up a test environment, execute the following command:</p> <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml\n</code></pre> <p>Note</p> <p>The above command will spawn a lazy fork of Polkadot Asset Hub with the latest block data from the network. If you need to test Kusama Asset Hub, replace <code>polkadot-asset-hub.yml</code> with <code>kusama-asset-hub.yml</code> in the command.</p> <p>An Asset Hub instance is now running locally, and you can proceed with the asset registration process. Note that the local registration process does not differ from the live network process. Once you have a successful TestNet transaction, you can use the same steps to register the asset on MainNet.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/","title":"Asset Transfer API","text":""},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#introduction","title":"Introduction","text":"<p>Asset Transfer API, a tool developed and maintained by Parity, is a specialized library designed to streamline asset transfers for Substrate-based blockchains. This API provides a simplified set of methods for users to:</p> <ul> <li>Execute asset transfers to other parachains or locally within the same chain</li> <li>Facilitate transactions involving system parachains like Asset Hub (Polkadot and Kusama)</li> </ul> <p>Using this API, developers can manage asset transfers more efficiently, reducing the complexity of cross-chain transactions and enabling smoother operations within the ecosystem.</p> <p>For additional support and information, please reach out through GitHub Issues.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Node.js (recommended version 21 or greater)</li> <li>Package manager - npm should be installed with Node.js by default. Alternatively, you can use other package managers like Yarn</li> </ul>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#install-asset-transfer-api","title":"Install Asset Transfer API","text":"<p>To use <code>asset-transfer-api</code>, you need a TypeScript project. If you don't have one, you can create a new one:</p> <ol> <li> <p>Create a new directory for your project:</p> <pre><code>mkdir my-asset-transfer-project \\\n&amp;&amp; cd my-asset-transfer-project\n</code></pre> </li> <li> <p>Initialize a new TypeScript project:</p> <pre><code>npm init -y \\\n&amp;&amp; npm install typescript ts-node @types/node --save-dev \\\n&amp;&amp; npx tsc --init\n</code></pre> </li> </ol> <p>Once you have a project set up, you can install the <code>asset-transfer-api</code> package:</p> <pre><code>npm install @substrate/asset-transfer-api@0.3.1\n</code></pre> <p>Note</p> <p>This documentation covers version <code>0.3.1</code> of Asset Transfer API.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#set-up-asset-transfer-api","title":"Set Up Asset Transfer API","text":"<p>To initialize the Asset Transfer API, you need three key components:</p> <ul> <li>A Polkadot.js API instance</li> <li>The <code>specName</code> of the chain</li> <li>The XCM version to use</li> </ul>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#using-helper-function-from-library","title":"Using Helper Function from Library","text":"<p>For a simpler setup process, you can leverage the <code>constructApiPromise</code> helper function provided by the library. It not only constructs a Polkadot.js <code>ApiPromise</code> but also automatically retrieves the chain's <code>specName</code> and fetches a safe XCM version. By using this function, developers can significantly reduce boilerplate code and potential configuration errors, making the initial setup both quicker and more robust.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"INSERT_WEBSOCKET_URL\"\n  );\n\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  // Your code using assetsApi goes here\n}\n\nmain();\n</code></pre> <p>Note</p> <p>The code examples are enclosed in an async main function to provide the necessary asynchronous context. However, you can use the code directly if you're already working within an async environment. The key is to ensure you're in an async context when working with these asynchronous operations, regardless of your specific setup.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#asset-transfer-api-reference","title":"Asset Transfer API Reference","text":"<p>For detailed information on the Asset Transfer API, including available methods, data types, and functionalities, refer to the Asset Transfer API Reference section. This resource provides in-depth explanations and technical specifications to help you integrate and utilize the API effectively.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#examples","title":"Examples","text":""},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#relay-to-system-parachain-transfer","title":"Relay to System Parachain Transfer","text":"<p>This example demonstrates how to initiate a cross-chain token transfer from a relay chain to a system parachain. Specifically, 1 WND will be transferred from a Westend (relay chain) account to a Westmint (system parachain) account.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://westend-rpc.polkadot.io\"\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      \"1000\",\n      \"5EWNeodpcQ6iYibJ3jmWVe85nsok1EDG8Kk3aFg8ZzpfY1qX\",\n      [\"WND\"],\n      [\"1000000000000\"],\n      {\n        format: \"call\",\n        xcmVersion: safeXcmVersion,\n      }\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, \"call\");\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>After running the script, you'll see the following output in the terminal, which shows the call data for the cross-chain transfer and its decoded extrinsic details:</p> ts-node relayToSystem.ts Call data: {     \"origin\": \"westend\",     \"dest\": \"westmint\",     \"direction\": \"RelayToSystem\",     \"xcmVersion\": 3,     \"method\": \"transferAssets\",     \"format\": \"call\",     \"tx\": \"0x630b03000100a10f03000101006c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d030400000000070010a5d4e80000000000\" } Decoded tx: {     \"args\": {         \"dest\": {             \"V3\": {                 \"parents\": \"0\",                 \"interior\": {                     \"X1\": {                         \"Parachain\": \"1,000\"                     }                 }             }         },         \"beneficiary\": {             \"V3\": {                 \"parents\": \"0\",                 \"interior\": {                     \"X1\": {                         \"AccountId32\": {                             \"network\": null,                             \"id\": \"0x6c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d\"                         }                     }                 }             }         },         \"assets\": {             \"V3\": [                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"0\",                             \"interior\": \"Here\"                         }                     },                     \"fun\": {                         \"Fungible\": \"1,000,000,000,000\"                     }                 }             ]         },         \"fee_asset_item\": \"0\",         \"weight_limit\": \"Unlimited\"     },     \"method\": \"transferAssets\",     \"section\": \"xcmPallet\" }"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#local-parachain-transfer","title":"Local Parachain Transfer","text":"<p>The following example demonstrates a local GLMR transfer within Moonbeam, using the <code>balances</code> pallet. It transfers 1 GLMR token from one account to another account, where both the sender and recipient accounts are located on the same parachain.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://wss.api.moonbeam.network\"\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      \"2004\",\n      \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",\n      [],\n      [\"1000000000000000000\"],\n      {\n        format: \"call\",\n        keepAlive: true,\n      }\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, \"call\");\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Upon executing this script, the terminal will display the following output, illustrating the encoded extrinsic for the cross-chain message and its corresponding decoded format:</p> ts-node localParachainTx.ts Call data: {     \"origin\": \"moonbeam\",     \"dest\": \"moonbeam\",     \"direction\": \"local\",     \"xcmVersion\": null,     \"method\": \"balances::transferKeepAlive\",     \"format\": \"call\",     \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\" } Decoded tx: {     \"args\": {         \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",         \"value\": \"1,000,000,000,000,000,000\"     },     \"method\": \"transferKeepAlive\",     \"section\": \"balances\" }"},{"location":"build-on-polkadot/xcm/asset-transfer-api/overview/#parachain-to-parachain-transfer","title":"Parachain to Parachain Transfer","text":"<p>This example demonstrates creating a cross-chain asset transfer between two parachains. It shows how to send vMOVR and vBNC from a Moonriver account to a Bifrost Kusama account using the safe XCM version. It connects to Moonriver, initializes the API, and uses the <code>createTransferTransaction</code> method to prepare a transaction.</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://moonriver.public.blastapi.io\"\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      \"2001\",\n      \"0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\",\n      [\"vMOVR\", \"72145018963825376852137222787619937732\"],\n      [\"1000000\", \"10000000000\"],\n      {\n        format: \"call\",\n        xcmVersion: safeXcmVersion,\n      }\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, \"call\");\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>After running this script, you'll see the following output in your terminal. This output presents the encoded extrinsic for the cross-chain message, along with its decoded format, providing a clear view of the transaction details.</p> ts-node paraToPara.ts Call data: {     \"origin\": \"moonriver\",     \"dest\": \"bifrost\",     \"direction\": \"ParaToPara\",     \"xcmVersion\": 2,     \"method\": \"transferMultiassets\",     \"format\": \"call\",     \"tx\": \"0x6a05010800010200451f06080101000700e40b540200010200451f0608010a0002093d000000000001010200451f0100c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\" } Decoded tx: {     \"args\": {         \"assets\": {             \"V2\": [                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"1\",                             \"interior\": {                                 \"X2\": [                                     {                                         \"Parachain\": \"2,001\"                                     },                                     {                                         \"GeneralKey\": \"0x0101\"                                     }                                 ]                             }                         }                     },                     \"fun\": {                         \"Fungible\": \"10,000,000,000\"                     }                 },                 {                     \"id\": {                         \"Concrete\": {                             \"parents\": \"1\",                             \"interior\": {                                 \"X2\": [                                     {                                         \"Parachain\": \"2,001\"                                     },                                     {                                         \"GeneralKey\": \"0x010a\"                                     }                                 ]                             }                         }                     },                     \"fun\": {                         \"Fungible\": \"1,000,000\"                     }                 }             ]         },         \"fee_item\": \"0\",         \"dest\": {             \"V2\": {                 \"parents\": \"1\",                 \"interior\": {                     \"X2\": [                         {                             \"Parachain\": \"2,001\"                         },                         {                             \"AccountId32\": {                                 \"network\": \"Any\",                                 \"id\": \"0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\"                             }                         }                     ]                 }             }         },         \"dest_weight_limit\": \"Unlimited\"     },     \"method\": \"transferMultiassets\",     \"section\": \"xTokens\" }"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/","title":"Asset Transfer API Reference","text":"<ul> <li> <p> Install the Asset Transfer API</p> <p>Learn how to install <code>asset-transfer-api</code> into a new or existing project.</p> <p>  Get started</p> </li> <li> <p> Dive in with a tutorial</p> <p>Ready to start coding? Follow along with a step-by-step tutorial.</p> <p>  How to use the Asset Transfer API</p> </li> </ul> <p></p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#asset-transfer-api-class","title":"Asset Transfer API Class","text":"<p>Holds open an API connection to a specified chain within the <code>ApiPromise</code> to help construct transactions for assets and estimate fees.</p> <p>For a more in-depth explanation of the Asset Transfer API class structure, check the source code.</p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#methods","title":"Methods","text":""},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#create-transfer-transaction","title":"Create Transfer Transaction","text":"<p>Generates an XCM transaction for transferring assets between chains. It simplifies the process by inferring what type of transaction is required given the inputs, ensuring that the assets are valid, and that the transaction details are correctly formatted.</p> <p>After obtaining the transaction, you must handle the signing and submission process separately.</p> <pre><code>public async createTransferTransaction&lt;T extends Format&gt;(\n  destChainId: string,\n  destAddr: string,\n  assetIds: string[],\n  amounts: string[],\n  opts: TransferArgsOpts&lt;T&gt; = {}\n): Promise&lt;TxResult&lt;T&gt;&gt;;\n</code></pre> Request parameters <p><code>destChainId</code> string required</p> <p>ID of the destination chain (<code>'0'</code> for relay chain, other values for parachains).</p> <p><code>destAddr</code> string required</p> <p>Address of the recipient account on the destination chain.</p> <p><code>assetIds</code> string[] required</p> <p>Array of asset IDs to be transferred.</p> <p>When asset IDs are provided, the API dynamically selects the appropriate pallet for the current chain to handle these specific assets. If the array is empty, the API defaults to using the <code>balances</code> pallet.</p> <p><code>amounts</code> string[] required</p> <p>Array of amounts corresponding to each asset in <code>assetIds</code>.</p> <p><code>opts</code> TransferArgsOpts&lt;T&gt;</p> <p>Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.</p> Show more <p><code>format</code> T extends Format </p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> <p><code>paysWithFeeOrigin</code> string</p> <p>The Asset ID to pay fees on the current common good parachain. The defaults are as follows:</p> <ul> <li>Polkadot Asset Hub - <code>'DOT'</code></li> <li>Kusama Asset Hub - <code>'KSM'</code></li> </ul> <p><code>paysWithFeeDest</code> string</p> <p>Asset ID to pay fees on the destination parachain.</p> <p><code>weightLimit</code> { refTime?: string, proofSize?: string }</p> <p>Custom weight limit option. If not provided, it will default to unlimited.</p> <p><code>xcmVersion</code> number</p> <p>Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.</p> <p><code>keepAlive</code> boolean</p> <p>Enables <code>transferKeepAlive</code> for local asset transfers. For creating local asset transfers, if <code>true</code> this will allow for a <code>transferKeepAlive</code> as opposed to a <code>transfer</code>.</p> <p><code>transferLiquidToken</code> boolean</p> <p>Declares if this will transfer liquidity tokens. Default is <code>false</code>.</p> <p><code>assetTransferType</code> string</p> <p>The XCM transfer type used to transfer assets. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <pre><code>export type AssetTransferType =\n  | LocalReserve\n  | DestinationReserve\n  | Teleport\n  | RemoteReserve;\n</code></pre> <p>Note</p> <p>To use the <code>assetTransferType</code> parameter, which is a string, you should use the <code>AssetTransferType</code> type as if each of its variants are strings. For example: <code>assetTransferType = 'LocalReserve'</code>.</p> <p><code>remoteReserveAssetTransferTypeLocation</code> string</p> <p>The remove reserve location for the XCM transfer. Should be provided when specifying an <code>assetTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>feesTransferType</code> string</p> <p>XCM TransferType used to pay fees for XCM transfer. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <pre><code>export type AssetTransferType =\n  | LocalReserve\n  | DestinationReserve\n  | Teleport\n  | RemoteReserve;\n</code></pre> <p>Note</p> <p>To use the <code>assetTransferType</code> parameter, which is a string, you should use the <code>AssetTransferType</code> type as if each of its variants are strings. For example: <code>assetTransferType = 'LocalReserve'</code>.</p> <p><code>remoteReserveFeesTransferTypeLocation</code> string</p> <p>The remote reserve location for the XCM transfer fees. Should be provided when specifying a <code>feesTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>customXcmOnDest</code> string</p> <p>A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:</p> <pre><code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n</code></pre> Response parameters <p>Promise&lt;TxResult&lt;T&gt;</p> <p>A promise containing the result of constructing the transaction.</p> Show more <p><code>dest</code> string</p> <p>The destination <code>specName</code> of the transaction.</p> <p><code>origin</code> string</p> <p>The origin <code>specName</code> of the transaction.</p> <p><code>format</code> Format | 'local'</p> <p>The format type the transaction is outputted in.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> <p><code>xcmVersion</code> number | null</p> <p>The XCM version that was used to construct the transaction.</p> <p><code>direction</code> Direction | 'local'</p> <p>The direction of the cross-chain transfer.</p> Enum <code>Direction</code> values <p><code>Local</code></p> <p>Local transaction.</p> <p><code>SystemToPara</code></p> <p>System parachain to parachain.</p> <p><code>SystemToRelay</code></p> <p>System paracahin to system relay chain.</p> <p><code>SystemToSystem</code></p> <p>System parachain to System parachain chain.</p> <p><code>SystemToBridge</code></p> <p>System parachain to an external <code>GlobalConsensus</code> chain.</p> <p><code>ParaToPara</code></p> <p>Parachain to Parachain.</p> <p><code>ParaToRelay</code></p> <p>Parachain to Relay chain.</p> <p><code>ParaToSystem</code></p> <p>Parachain to System parachain.</p> <p><code>RelayToSystem</code></p> <p>Relay to System Parachain.</p> <p><code>RelayToPara</code></p> <p>Relay chain to Parachain.</p> <p><code>RelayToBridge</code></p> <p>Relay chain to an external <code>GlobalConsensus</code> chain.</p> <p><code>method</code> Methods</p> <p>The method used in the transaction.</p> Type <code>Methods</code> <pre><code>type Methods =\n  | LocalTransferTypes\n  | 'transferAssets'\n  | 'transferAssetsUsingTypeAndThen'\n  | 'limitedReserveTransferAssets'\n  | 'limitedTeleportAssets'\n  | 'transferMultiasset'\n  | 'transferMultiassets'\n  | 'transferMultiassetWithFee'\n  | 'claimAssets';\n</code></pre> Type <code>LocalTransferTypes</code> <pre><code>type LocalTransferTypes =\n  | 'assets::transfer'\n  | 'assets::transferKeepAlive'\n  | 'foreignAssets::transfer'\n  | 'foreignAssets::transferKeepAlive'\n  | 'balances::transfer'\n  | 'balances::transferKeepAlive'\n  | 'poolAssets::transfer'\n  | 'poolAssets::transferKeepAlive'\n  | 'tokens::transfer'\n  | 'tokens::transferKeepAlive';\n</code></pre> <p><code>tx</code> ConstructedFormat&lt;T&gt;</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> <pre><code>export type ConstructedFormat&lt;T&gt; = T extends 'payload'\n  ? GenericExtrinsicPayload\n  : T extends 'call'\n  ? `0x${string}`\n  : T extends 'submittable'\n  ? SubmittableExtrinsic&lt;'promise', ISubmittableResult&gt;\n  : never;\n</code></pre> <p>The <code>ConstructedFormat</code> type is a conditional type that returns a specific type based on the value of the TxResult <code>format</code> field.</p> <ul> <li>Payload format - if the format field is set to <code>'payload'</code>, the <code>ConstructedFormat</code> type will return a <code>GenericExtrinsicPayload</code></li> <li>Call format - if the format field is set to <code>'call'</code>, the <code>ConstructedFormat</code> type will return a hexadecimal string (<code>0x${string}</code>). This is the encoded representation of the extrinsic call</li> <li>Submittable format - if the format field is set to <code>'submittable'</code>, the <code>ConstructedFormat</code> type will return a <code>SubmittableExtrinsic</code>. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain</li> </ul> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://wss.api.moonbeam.network\"\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.createTransferTransaction(\n      \"2004\",\n      \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",\n      [],\n      [\"1000000000000000000\"],\n      {\n        format: \"call\",\n        keepAlive: true,\n      }\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Call data: {     \"origin\": \"moonbeam\",     \"dest\": \"moonbeam\",     \"direction\": \"local\",     \"xcmVersion\": null,     \"method\": \"balances::transferKeepAlive\",     \"format\": \"call\",     \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\" }"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#claim-assets","title":"Claim Assets","text":"<p>Creates a local XCM transaction to retrieve trapped assets. This function can be used to claim assets either locally on a system parachain, on the relay chain, or on any chain that supports the <code>claimAssets</code> runtime call.</p> <pre><code>public async claimAssets&lt;T extends Format&gt;(\n  assetIds: string[],\n  amounts: string[],\n  beneficiary: string,\n  opts: TransferArgsOpts&lt;T&gt;\n): Promise&lt;TxResult&lt;T&gt;&gt;;\n</code></pre> Request parameters <p><code>assetIds</code> string[] required</p> <p>Array of asset IDs to be claimed from the <code>AssetTrap</code>.</p> <p><code>amounts</code> string[] required</p> <p>Array of amounts corresponding to each asset in <code>assetIds</code>.</p> <p><code>beneficiary</code> string required</p> <p>Address of the account to receive the trapped assets.</p> <p><code>opts</code> TransferArgsOpts&lt;T&gt;</p> <p>Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.</p> Show more <p><code>format</code> T extends Format </p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> <p><code>paysWithFeeOrigin</code> string</p> <p>The Asset ID to pay fees on the current common good parachain. The defaults are as follows:</p> <ul> <li>Polkadot Asset Hub - <code>'DOT'</code></li> <li>Kusama Asset Hub - <code>'KSM'</code></li> </ul> <p><code>paysWithFeeDest</code> string</p> <p>Asset ID to pay fees on the destination parachain.</p> <p><code>weightLimit</code> { refTime?: string, proofSize?: string }</p> <p>Custom weight limit option. If not provided, it will default to unlimited.</p> <p><code>xcmVersion</code> number</p> <p>Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.</p> <p><code>keepAlive</code> boolean</p> <p>Enables <code>transferKeepAlive</code> for local asset transfers. For creating local asset transfers, if <code>true</code> this will allow for a <code>transferKeepAlive</code> as opposed to a <code>transfer</code>.</p> <p><code>transferLiquidToken</code> boolean</p> <p>Declares if this will transfer liquidity tokens. Default is <code>false</code>.</p> <p><code>assetTransferType</code> string</p> <p>The XCM transfer type used to transfer assets. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <pre><code>export type AssetTransferType =\n  | LocalReserve\n  | DestinationReserve\n  | Teleport\n  | RemoteReserve;\n</code></pre> <p>Note</p> <p>To use the <code>assetTransferType</code> parameter, which is a string, you should use the <code>AssetTransferType</code> type as if each of its variants are strings. For example: <code>assetTransferType = 'LocalReserve'</code>.</p> <p><code>remoteReserveAssetTransferTypeLocation</code> string</p> <p>The remove reserve location for the XCM transfer. Should be provided when specifying an <code>assetTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>feesTransferType</code> string</p> <p>XCM TransferType used to pay fees for XCM transfer. The <code>AssetTransferType</code> type defines the possible values for this parameter.</p> Type <code>AssetTransferType</code> <pre><code>export type AssetTransferType =\n  | LocalReserve\n  | DestinationReserve\n  | Teleport\n  | RemoteReserve;\n</code></pre> <p>Note</p> <p>To use the <code>assetTransferType</code> parameter, which is a string, you should use the <code>AssetTransferType</code> type as if each of its variants are strings. For example: <code>assetTransferType = 'LocalReserve'</code>.</p> <p><code>remoteReserveFeesTransferTypeLocation</code> string</p> <p>The remote reserve location for the XCM transfer fees. Should be provided when specifying a <code>feesTransferType</code> of <code>RemoteReserve</code>.</p> <p><code>customXcmOnDest</code> string</p> <p>A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:</p> <pre><code>Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n</code></pre> Response parameters <p>Promise&lt;TxResult&lt;T&gt;&gt;</p> <p>A promise containing the result of constructing the transaction.</p> Show more <p><code>dest</code> string</p> <p>The destination <code>specName</code> of the transaction.</p> <p><code>origin</code> string</p> <p>The origin <code>specName</code> of the transaction.</p> <p><code>format</code> Format | 'local'</p> <p>The format type the transaction is outputted in.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> <p><code>xcmVersion</code> number | null</p> <p>The XCM version that was used to construct the transaction.</p> <p><code>direction</code> Direction | 'local'</p> <p>The direction of the cross-chain transfer.</p> Enum <code>Direction</code> values <p><code>Local</code></p> <p>Local transaction.</p> <p><code>SystemToPara</code></p> <p>System parachain to parachain.</p> <p><code>SystemToRelay</code></p> <p>System paracahin to system relay chain.</p> <p><code>SystemToSystem</code></p> <p>System parachain to System parachain chain.</p> <p><code>SystemToBridge</code></p> <p>System parachain to an external <code>GlobalConsensus</code> chain.</p> <p><code>ParaToPara</code></p> <p>Parachain to Parachain.</p> <p><code>ParaToRelay</code></p> <p>Parachain to Relay chain.</p> <p><code>ParaToSystem</code></p> <p>Parachain to System parachain.</p> <p><code>RelayToSystem</code></p> <p>Relay to System Parachain.</p> <p><code>RelayToPara</code></p> <p>Relay chain to Parachain.</p> <p><code>RelayToBridge</code></p> <p>Relay chain to an external <code>GlobalConsensus</code> chain.</p> <p><code>method</code> Methods</p> <p>The method used in the transaction.</p> Type <code>Methods</code> <pre><code>type Methods =\n  | LocalTransferTypes\n  | 'transferAssets'\n  | 'transferAssetsUsingTypeAndThen'\n  | 'limitedReserveTransferAssets'\n  | 'limitedTeleportAssets'\n  | 'transferMultiasset'\n  | 'transferMultiassets'\n  | 'transferMultiassetWithFee'\n  | 'claimAssets';\n</code></pre> Type <code>LocalTransferTypes</code> <pre><code>type LocalTransferTypes =\n  | 'assets::transfer'\n  | 'assets::transferKeepAlive'\n  | 'foreignAssets::transfer'\n  | 'foreignAssets::transferKeepAlive'\n  | 'balances::transfer'\n  | 'balances::transferKeepAlive'\n  | 'poolAssets::transfer'\n  | 'poolAssets::transferKeepAlive'\n  | 'tokens::transfer'\n  | 'tokens::transferKeepAlive';\n</code></pre> <p><code>tx</code> ConstructedFormat&lt;T&gt;</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> <pre><code>export type ConstructedFormat&lt;T&gt; = T extends 'payload'\n  ? GenericExtrinsicPayload\n  : T extends 'call'\n  ? `0x${string}`\n  : T extends 'submittable'\n  ? SubmittableExtrinsic&lt;'promise', ISubmittableResult&gt;\n  : never;\n</code></pre> <p>The <code>ConstructedFormat</code> type is a conditional type that returns a specific type based on the value of the TxResult <code>format</code> field.</p> <ul> <li>Payload format - if the format field is set to <code>'payload'</code>, the <code>ConstructedFormat</code> type will return a <code>GenericExtrinsicPayload</code></li> <li>Call format - if the format field is set to <code>'call'</code>, the <code>ConstructedFormat</code> type will return a hexadecimal string (<code>0x${string}</code>). This is the encoded representation of the extrinsic call</li> <li>Submittable format - if the format field is set to <code>'submittable'</code>, the <code>ConstructedFormat</code> type will return a <code>SubmittableExtrinsic</code>. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain</li> </ul> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://westend-rpc.polkadot.io\"\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.claimAssets(\n      [\n        `{\"parents\":\"0\",\"interior\":{\"X2\":[{\"PalletInstance\":\"50\"},{\"GeneralIndex\":\"1984\"}]}}`,\n      ],\n      [\"1000000000000\"],\n      \"0xf5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b\",\n      {\n        format: \"call\",\n        xcmVersion: 2,\n      }\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Call data: {     \"origin\": \"0\",     \"dest\": \"westend\",     \"direction\": \"local\",     \"xcmVersion\": 2,     \"method\": \"claimAssets\",     \"format\": \"call\",     \"tx\": \"0x630c0104000002043205011f00070010a5d4e80100010100f5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b\" }"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#decode-extrinsic","title":"Decode Extrinsic","text":"<p>Decodes the hex of an extrinsic into a string readable format.</p> <pre><code>public decodeExtrinsic&lt;T extends Format&gt;(\n  encodedTransaction: string,\n  format: T\n): string;\n</code></pre> Request parameters <p><code>encodedTransaction</code> string required</p> <p>A hex encoded extrinsic.</p> <p><code>format</code> T extends Format required</p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> Response parameters <p>string</p> <p>Decoded extrinsic in string readable format.</p> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://wss.api.moonbeam.network\"\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\";\n\n  try {\n    const decodedExt = assetsApi.decodeExtrinsic(encodedExt, \"call\");\n    console.log(\n      `Decoded tx:\\n ${JSON.stringify(JSON.parse(decodedExt), null, 4)}`\n    );\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Decoded tx:  {     \"args\": {         \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",         \"value\": \"100,000\"     },     \"method\": \"transferKeepAlive\",     \"section\": \"balances\" } </p>"},{"location":"build-on-polkadot/xcm/asset-transfer-api/reference/#fetch-fee-info","title":"Fetch Fee Info","text":"<p>Fetch estimated fee information for an extrinsic.</p> <pre><code>public async fetchFeeInfo&lt;T extends Format&gt;(\n  tx: ConstructedFormat&lt;T&gt;,\n  format: T\n): Promise&lt;RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null&gt;;\n</code></pre> Request parameters <p><code>tx</code> ConstructedFormat&lt;T&gt; required</p> <p>The constructed transaction.</p> Type <code>ConstructedFormat&lt;T&gt;</code> <pre><code>export type ConstructedFormat&lt;T&gt; = T extends 'payload'\n  ? GenericExtrinsicPayload\n  : T extends 'call'\n  ? `0x${string}`\n  : T extends 'submittable'\n  ? SubmittableExtrinsic&lt;'promise', ISubmittableResult&gt;\n  : never;\n</code></pre> <p>The <code>ConstructedFormat</code> type is a conditional type that returns a specific type based on the value of the TxResult <code>format</code> field.</p> <ul> <li>Payload format - if the format field is set to <code>'payload'</code>, the <code>ConstructedFormat</code> type will return a <code>GenericExtrinsicPayload</code></li> <li>Call format - if the format field is set to <code>'call'</code>, the <code>ConstructedFormat</code> type will return a hexadecimal string (<code>0x${string}</code>). This is the encoded representation of the extrinsic call</li> <li>Submittable format - if the format field is set to <code>'submittable'</code>, the <code>ConstructedFormat</code> type will return a <code>SubmittableExtrinsic</code>. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain</li> </ul> <p><code>format</code> T extends Format required</p> <p>Specifies the format for returning a transaction.</p> Type <code>Format</code> <pre><code>export type Format = \"payload\" | \"call\" | \"submittable\";\n</code></pre> Response parameters <p>Promise&lt;RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null&gt;</p> <p>A promise containing the estimated fee information for the provided extrinsic.</p> Type <code>RuntimeDispatchInfo</code> <pre><code>export interface RuntimeDispatchInfo extends Struct {\n  readonly weight: Weight;\n  readonly class: DispatchClass;\n  readonly partialFee: Balance;\n}\n</code></pre> <p>For more information on the underlying types and fields of <code>RuntimeDispatchInfo</code>, check the RuntimeDispatchInfo source code.</p> Type <code>RuntimeDispatchInfoV1</code> <pre><code>export interface RuntimeDispatchInfoV1 extends Struct {\n  readonly weight: WeightV1;\n  readonly class: DispatchClass;\n  readonly partialFee: Balance;\n}\n</code></pre> <p>For more information on the underlying types and fields of <code>RuntimeDispatchInfoV1</code>, check the RuntimeDispatchInfoV1 source code.</p> Example <p>Request</p> <pre><code>import {\n  AssetTransferApi,\n  constructApiPromise,\n} from \"@substrate/asset-transfer-api\";\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    \"wss://wss.api.moonbeam.network\"\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\";\n\n  try {\n    const decodedExt = await assetsApi.fetchFeeInfo(encodedExt, \"call\");\n    console.log(`Fee info:\\n${JSON.stringify(decodedExt, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) =&gt; console.error(err))\n  .finally(() =&gt; process.exit());\n</code></pre> <p>Response</p> <p> Fee info: {     \"weight\": {         \"refTime\": 163777000,         \"proofSize\": 3581     },     \"class\": \"Normal\",     \"partialFee\": 0 } </p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/overview/","title":"HRMP Channels","text":""},{"location":"build-on-polkadot/xcm/hrmp-channels/overview/#introduction","title":"Introduction","text":"<p>Polkadot is designed to enable seamless interoperability between its connected parachains. At the core of this interoperability is the Cross-Consensus Message Format (XCM), a standard language that allows parachains to communicate and interact with each other.</p> <p>The network-layer protocol responsible for delivering XCM-formatted messages between parachains is the Cross-Chain Message Passing (XCMP) protocol. XCMP maintains messaging queues on the relay chain, serving as a bridge to facilitate cross-chain interactions.</p> <p>As XCMP is still under development, Polkadot has implemented a temporary alternative called Horizontal Relay-routed Message Passing (HRMP). HRMP offers the same interface and functionality as the planned XCMP but it has a crucial difference, it stores all messages directly in the relay chain\u2019s storage, which is more resource-intensive.</p> <p>Once XCMP is fully implemented, HRMP will be deprecated in favor of the native XCMP protocol. XCMP will offer a more efficient and scalable solution for cross-chain message passing, as it will not require the relay chain to store all the messages.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/overview/#establishing-hrmp-channels","title":"Establishing HRMP Channels","text":"<p>To enable communication between parachains using the HRMP protocol, the parachains must explicitly establish communication channels by registering them on the relay chain.</p> <p>Downward and upward channels from and to the relay chain are implicitly available, meaning they do not need to be explicitly opened.</p> <p>Opening an HRMP channel requires the parachains involved to make a deposit on the relay chain. This deposit serves a specific purpose, it covers the costs associated with using the relay chain's storage for the message queues linked to the channel. The amount of this deposit varies based on parameters defined by the specific relay chain being used.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/overview/#relay-chain-parameters","title":"Relay Chain Parameters","text":"<p>Each Polkadot relay chain has a set of configurable parameters that control the behavior of the message channels between parachains. These parameters include <code>hrmpSenderDeposit</code>, <code>hrmpRecipientDeposit</code>, <code>hrmpChannelMaxMessageSize</code>, <code>hrmpChannelMaxCapacity</code>, and more.</p> <p>When a parachain wants to open a new channel, it must consider these parameter values to ensure the channel is configured correctly.</p> <p>To view the current values of these parameters in the Polkadot network:</p> <ol> <li> <p>Visit Polkadot.js Apps, navigate to the Developer dropdown and select the Chain state option</p> <p></p> </li> <li> <p>Query the chain configuration parameters. The result will display the current settings for all the Polkadot network parameters, including the HRMP channel settings</p> <ol> <li>Select configuration</li> <li>Choose the activeConfig() call</li> <li>Click the + button to execute the query</li> <li>Check the chain configuration</li> </ol> <p></p> </li> </ol>"},{"location":"build-on-polkadot/xcm/hrmp-channels/overview/#dispatching-extrinsics","title":"Dispatching Extrinsics","text":"<p>Establishing new HRMP channels between parachains requires dispatching specific extrinsic calls on the Polkadot relay chain from the parachain's origin.</p> <p>The most straightforward approach is to implement the channel opening logic off-chain, then use the XCM pallet's <code>send</code> extrinsic to submit the necessary instructions to the relay chain. However, the ability to send arbitrary programs through the <code>Transact</code> instruction in XCM is typically restricted to privileged origins, such as the <code>sudo</code> pallet or governance mechanisms.</p> <p>Parachain developers have a few options for triggering the required extrinsic calls from their parachain's origin, depending on the configuration and access controls defined:</p> <ul> <li>Sudo - if the parachain has a <code>sudo</code> pallet configured, the sudo key holder can use the sudo extrinsic to dispatch the necessary channel opening calls</li> <li>Governance - the parachain's governance system, such as a council or OpenGov, can be used to authorize the channel opening calls</li> <li>Privileged Accounts - the parachain may have other designated privileged accounts that are allowed to dispatch the HRMP channel opening extrinsics</li> </ul>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/","title":"Opening HRMP Channels Between Parachains","text":""},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#introduction","title":"Introduction","text":"<p>For establishing communication channels between parachains on the Polkadot network using the Horizontal Relay-routed Message Passing (HRMP) protocol, the following steps are required:</p> <ol> <li>Channel request - the parachain that wants to open an HRMP channel must make a request to the parachain it wishes to have an open channel with</li> <li>Channel acceptance - the other parachain must then accept this request to complete the channel establishment</li> </ol> <p>This process results in a unidirectional HRMP channel, where messages can flow in only one direction between the two parachains.</p> <p>An additional HRMP channel must be established in the opposite direction to enable bidirectional communication. This requires repeating the request and acceptance process but with the parachains reversing their roles.</p> <p>Once both unidirectional channels are established, the parachains can send messages back and forth freely through the bidirectional HRMP communication channel.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you meet the following requirements:</p> <ul> <li>Blockchain network with a relay chain and at least two connected parachains</li> <li>Wallet with sufficient funds to execute transactions on the participant chains</li> </ul>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#procedure-for-initiating-hrmp-channel-setup","title":"Procedure for Initiating HRMP Channel Setup","text":"<p>This example will demonstrate how to open a channel between parachain 2500 and parachain 2600, using Rococo Local as the relay chain.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-1-fund-sender-sovereign-account","title":"Step 1 - Fund Sender Sovereign Account","text":"<p>The sovereign account for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.</p> <p>Use Polkadot.js Apps UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account. </p> Calculating Parachain Sovereign Account <p>To generate the sovereign account address for a parachain, you'll need to follow these steps:</p> <ol> <li> <p>Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:</p> <ul> <li> <p>Up/down chains use the prefix <code>0x70617261</code> (which decodes to <code>b\"para\"</code>)</p> </li> <li> <p>Sibling chains use the prefix <code>0x7369626c</code> (which decodes to <code>b\"sibl\"</code>)</p> </li> </ul> </li> <li> <p>Calculate the u32 scale encoded value of the parachain ID:</p> <ul> <li>Parachain 2500 would be encoded as <code>c4090000</code></li> </ul> </li> <li> <p>Combine the prefix and parachain ID encoding to form the full sovereign account address:</p> <p>The sovereign account of parachain 2500 in relay chain will be <code>0x70617261c4090000000000000000000000000000000000000000000000000000</code> and the SS58 format of this address is <code>5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y</code></p> </li> </ol> <p>To perform this conversion, you can also use the \"Para ID\" to Address section in Substrate Utilities.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-2-create-channel-opening-extrinsic","title":"Step 2 - Create Channel Opening Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>hrmpInitOpenChannel</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>hrmpInitOpenChannel</code> extrinsic</li> <li>Fill in the parameters<ul> <li><code>recipient</code> - parachain ID of the target chain (in this case, 2600)</li> <li><code>proposedMaxCapacity</code> - max number of messages that can be pending in the channel at once</li> <li><code>proposedMaxMessageSize</code> - max message size that could be put into the channel</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for opening a channel with parachain 2600 is <code>0x3c00280a00000800000000001000</code>.</li> </ol> </li> </ol>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-3-crafting-and-submitting-the-xcm-message-from-the-sender","title":"Step 3 - Crafting and Submitting the XCM Message from the Sender","text":"<p>To initiate the HRMP channel opening process, you need to create an XCM message that includes the encoded <code>hrmpInitOpenChannel</code> call data from the previous step. This message will be sent from your parachain to the relay chain.</p> <p>This example uses the <code>sudo</code> pallet to dispatch the extrinsic. Verify the XCM configuration of the parachain you're working with and ensure you're using an origin with the necessary privileges to execute the <code>polkadotXcm.send</code> extrinsic.</p> <p>The XCM message should contain the following instructions:</p> <ul> <li><code>WithdrawAsset</code> - withdraws assets from the origin's ownership and places them in the Holding Register</li> <li><code>BuyExecution</code> - pays for the execution of the current message using the assets in the Holding Register</li> <li><code>Transact</code> - execute the encoded transaction call</li> <li><code>RefundSurplus</code> - increases the Refunded Weight Register to the value of the Surplus Weight Register, attempting to reclaim any excess fees paid via BuyExecution</li> <li><code>DepositAsset</code> - subtracts assets from the Holding Register and deposits equivalent on-chain assets under the specified beneficiary's ownership</li> </ul> <p>Note</p> <p>For more detailed information about XCM's functionality, complexities, and instruction set, refer to the xcm-format documentation.</p> <p>In essence, this process withdraws funds from the parachain's sovereign account to the XCVM Holding Register, then uses these funds to purchase execution time for the XCM <code>Transact</code> instruction, executes <code>Transact</code>, refunds any unused execution time and deposits any remaining funds into a specified account.</p> <p>To send the XCM message to the relay chain, connect to parachain 2500 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:</p> <ol> <li>Replace the <code>call</code> field with your encoded <code>hrmpInitOpenChannel</code> call data from the previous step</li> <li>Use the correct beneficiary information</li> <li>Click the Submit Transaction button to dispatch the XCM message to the relay chain</li> </ol> <p></p> <p>Note</p> <p>The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.</p> <p>After submitting the XCM message to initiate the HRMP channel opening, you should verify that the request was successful. Follow these steps to check the status of your channel request:</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select the Chain state option</p> <p></p> </li> <li> <p>Query the HRMP open channel requests</p> <ol> <li>Select <code>hrmp</code></li> <li>Choose the <code>hrmpOpenChannelRequests</code> call</li> <li>Click the + button to execute the query</li> <li>Check the status of all pending channel requests</li> </ol> <p></p> </li> </ol> <p>If your channel request was successful, you should see an entry for your parachain ID in the list of open channel requests. This confirms that your request has been properly registered on the relay chain and is awaiting acceptance by the target parachain.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#procedure-for-accepting-hrmp-channel","title":"Procedure for Accepting HRMP Channel","text":"<p>For the channel to be fully established, the target parachain must accept the channel request by submitting an XCM message to the relay chain.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-1-fund-receiver-sovereign-account","title":"Step 1 - Fund Receiver Sovereign Account","text":"<p>Before proceeding, ensure that the sovereign account of parachain 2600 on the relay chain is funded. This account will be responsible for covering any XCM transact fees. To fund the account, follow the same process described in the previous section Step 1 - Fund Sovereign Account.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-2-create-channel-accepting-extrinsic","title":"Step 2 - Create Channel Accepting Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>hrmpAcceptOpenChannel</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>hrmpAcceptOpenChannel</code> extrinsic</li> <li>Fill in the parameters:<ul> <li><code>sender</code> - parachain ID of the requesting chain (in this case, 2500)</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for accepting a channel with parachain 2500 should be <code>0x3c01c4090000</code></li> </ol> </li> </ol>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-para/#step-3-crafting-and-submitting-the-xcm-message-from-the-receiver","title":"Step 3 - Crafting and Submitting the XCM Message from the Receiver","text":"<p>To accept the HRMP channel opening, you need to create and submit an XCM message that includes the encoded <code>hrmpAcceptOpenChannel</code> call data from the previous step. This process is similar to the one described in the previous section's Step 3 - Crafting and Submitting the XCM Message, with a few key differences:</p> <ul> <li>Use the encoded call data for <code>hrmpAcceptOpenChannel</code> obtained in Step 2 of this section</li> <li>In the last XCM instruction (DepositAsset), set the beneficiary to parachain 2600's sovereign account to receive any surplus funds</li> </ul> <p>To send the XCM message to the relay chain, connect to parachain 2600 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:</p> <ol> <li>Replace the <code>call</code> field with your encoded <code>hrmpAcceptOpenChannel</code> call data from the previous step</li> <li>Use the correct beneficiary information</li> <li>Click the Submit Transaction button to dispatch the XCM message to the relay chain</li> </ol> <p></p> <p>After submitting the XCM message to accept the HRMP channel opening, verify that the channel has been set up correctly.</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select the Chain state option</p> <p></p> </li> <li> <p>Query the HRMP channels</p> <ol> <li>Select <code>hrmp</code></li> <li>Choose the <code>hrmpChannels</code> call</li> <li>Click the + button to execute the query</li> <li>Check the status of the opened channel</li> </ol> <p></p> </li> </ol> <p>If the channel has been successfully established, you should see the channel details in the query results.</p> <p>By following these steps, you will have successfully accepted the HRMP channel request and established a unidirectional channel between the two parachains. </p> <p>Note</p> <p>Remember that for full bidirectional communication, you'll need to repeat this process in the opposite direction, with parachain 2600 initiating a channel request to parachain 2500.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/","title":"Opening HRMP Channels with System Parachains","text":""},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#introduction","title":"Introduction","text":"<p>While establishing Horizontal Relay-routed Message Passing (HRMP) channels between regular parachains involves a two-step request and acceptance procedure, opening channels with system parachains follows a more straightforward approach.</p> <p>System parachains are specialized chains that provide core functionality to the Polkadot network. Examples include Asset Hub for cross-chain asset transfers and Bridge Hub for connecting to external networks. Given their critical role, establishing communication channels with these system parachains has been optimized for efficiency and ease of use.</p> <p>Any parachain can establish a bidirectional channel with a system chain through a single operation, requiring just one XCM message from the parachain to the relay chain.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#prerequisites","title":"Prerequisites","text":"<p>To successfully complete this process, you'll need to have the following in place:</p> <ul> <li>Access to a blockchain network consisting of:<ul> <li>A relay chain</li> <li>A parachain</li> <li>An Asset Hub system chain</li> </ul> </li> <li>A wallet containing enough funds to cover transaction fees on each of the participating chains</li> </ul>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#procedure-for-establishing-hrmp-channel","title":"Procedure for Establishing HRMP Channel","text":"<p>This guide demonstrates opening an HRMP channel between parachain 2500 and system chain Asset Hub (parachain 1000) on the Rococo Local relay chain.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#step-1-fund-parachain-sovereign-account","title":"Step 1 - Fund Parachain Sovereign Account","text":"<p>The sovereign account for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.</p> <p>Use Polkadot.js Apps UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account. </p> Calculating Parachain Sovereign Account <p>To generate the sovereign account address for a parachain, you'll need to follow these steps:</p> <ol> <li> <p>Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:</p> <ul> <li> <p>Up/down chains use the prefix <code>0x70617261</code> (which decodes to <code>b\"para\"</code>)</p> </li> <li> <p>Sibling chains use the prefix <code>0x7369626c</code> (which decodes to <code>b\"sibl\"</code>)</p> </li> </ul> </li> <li> <p>Calculate the u32 scale encoded value of the parachain ID:</p> <ul> <li>Parachain 2500 would be encoded as <code>c4090000</code></li> </ul> </li> <li> <p>Combine the prefix and parachain ID encoding to form the full sovereign account address:</p> <p>The sovereign account of parachain 2500 in relay chain will be <code>0x70617261c4090000000000000000000000000000000000000000000000000000</code> and the SS58 format of this address is <code>5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y</code></p> </li> </ol> <p>To perform this conversion, you can also use the \"Para ID\" to Address section in Substrate Utilities.</p>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#step-2-create-establish-channel-with-system-extrinsic","title":"Step 2 - Create Establish Channel with System Extrinsic","text":"<ol> <li> <p>In Polkadot.js Apps, connect to the relay chain, navigate to the Developer dropdown and select the Extrinsics option</p> <p></p> </li> <li> <p>Construct an <code>establish_channel_with_system</code> extrinsic call</p> <ol> <li>Select the <code>hrmp</code> pallet</li> <li>Choose the <code>establish_channel_with_system</code> extrinsic</li> <li>Fill in the parameters:<ul> <li><code>target_system_chain</code> - parachain ID of the target system chain (in this case, 1000)</li> </ul> </li> <li>Copy the encoded call data  The encoded call data for establishing a channel with system parachain 1000 should be <code>0x3c0ae8030000</code></li> </ol> </li> </ol>"},{"location":"build-on-polkadot/xcm/hrmp-channels/para-to-system/#step-3-crafting-and-submitting-the-xcm-message","title":"Step 3 - Crafting and Submitting the XCM Message","text":"<p>Connect to parachain 2500 using Polkadot.js Apps to send the XCM message to the relay chain. Input the necessary parameters as illustrated in the image below. Make sure to:</p> <ol> <li>Insert your previously encoded <code>establish_channel_with_system</code> call data into the <code>call</code> field</li> <li>Provide beneficiary details</li> <li>Dispatch the XCM message to the relay chain by clicking the Submit Transaction button </li> </ol> <p>Note</p> <p>The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.</p> <p>After successfully submitting the XCM message to the relay chain, two HRMP channels should be created, establishing bidirectional communication between parachain 2500 and system chain 1000. To verify this, follow these steps:</p> <ol> <li> <p>Using Polkadot.js Apps, connect to the relay chain and navigate to the Developer dropdown, then select Chain state </p> </li> <li> <p>Query the HRMP channels</p> <ol> <li>Select <code>hrmp</code> from the options</li> <li>Choose the <code>hrmpChannels</code> call</li> <li>Click the + button to execute the query </li> </ol> </li> <li> <p>Examine the query results. You should see output similar to the following:     <pre><code>[\n  [\n    [\n      {\n        \"sender\": 1000,\n        \"recipient\": 2500\n      }\n    ],\n    {\n      \"maxCapacity\": 8,\n      \"maxTotalSize\": 8192,\n      \"maxMessageSize\": 1048576,\n      \"msgCount\": 0,\n      \"totalSize\": 0,\n      \"mqcHead\": null,\n      \"senderDeposit\": 0,\n      \"recipientDeposit\": 0\n    }\n  ],\n  [\n    [\n      {\n        \"sender\": 2500,\n        \"recipient\": 1000\n      }\n    ],\n    {\n      \"maxCapacity\": 8,\n      \"maxTotalSize\": 8192,\n      \"maxMessageSize\": 1048576,\n      \"msgCount\": 0,\n      \"totalSize\": 0,\n      \"mqcHead\": null,\n      \"senderDeposit\": 0,\n      \"recipientDeposit\": 0\n    }\n  ]\n]\n</code></pre></p> </li> </ol> <p>The output confirms the successful establishment of two HRMP channels:</p> <ul> <li>From chain 1000 (system chain) to chain 2500 (parachain)</li> <li>From chain 2500 (parachain) to chain 1000 (system chain)</li> </ul> <p>This bidirectional channel enables direct communication between the system chain and the parachain, allowing for cross-chain message passing.</p>"},{"location":"dev-tools/chopsticks/overview/","title":"Chopsticks","text":""},{"location":"dev-tools/chopsticks/overview/#introduction","title":"Introduction","text":"<p>Chopsticks, created and maintained by the Acala Foundation, is a powerful tool designed to enhance the development process for Substrate-based blockchains. It offers developers a user-friendly method to locally fork existing chains, enabling them to:</p> <ul> <li>Experiment with custom blockchain configurations in a local environment</li> <li>Replay blocks and analyze how extrinsics affect state</li> <li>Fork multiple blocks for comprehensive XCM testing</li> </ul> <p>With Chopsticks, developers can simulate and test complex blockchain scenarios without deploying to a live network. This tool significantly reduces the complexity of building blockchain applications on Substrate, making it more accessible to developers of varying experience levels. Ultimately, Chopsticks aims to accelerate innovation in the Substrate ecosystem by providing a robust, flexible testing framework.</p> <p>For additional support and information, please reach out through GitHub Issues.</p> <p>Note</p> <p>Chopsticks uses Smoldot light client, which only supports the native Polkadot SDK API. Consequently, a Chopsticks-based fork doesn't support Ethereum JSON-RPC calls, so you cannot use it to fork your chain and connect Metamask.</p>"},{"location":"dev-tools/chopsticks/overview/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Node.js</li> <li>A package manager such as npm, which should be installed with Node.js by default, or Yarn</li> </ul>"},{"location":"dev-tools/chopsticks/overview/#install-chopsticks","title":"Install Chopsticks","text":"<p>You can install Chopsticks either globally or locally in your project. Choose the option that best fits your development workflow.</p> <p>Note</p> <p>This documentation explains the features of Chopsticks version <code>0.13.1</code>. Make sure you're using the correct version to match these instructions.</p>"},{"location":"dev-tools/chopsticks/overview/#global-installation","title":"Global Installation","text":"<p>To install Chopsticks globally, allowing you to use it across multiple projects, run:</p> <pre><code>npm i -g @acala-network/chopsticks@0.13.1\n</code></pre> <p>Now, you should be able to run the <code>chopsticks</code> command from your terminal.</p>"},{"location":"dev-tools/chopsticks/overview/#local-installation","title":"Local Installation","text":"<p>To use Chopsticks in a specific project, first create a new directory and initialize a Node.js project:</p> <pre><code>mkdir my-chopsticks-project\ncd my-chopsticks-project\nnpm init -y\n</code></pre> <p>Then, install Chopsticks as a local dependency:</p> <pre><code>npm i @acala-network/chopsticks@0.13.1\n</code></pre> <p>Finally, you can run Chopsticks using the <code>npx</code> command:</p> <pre><code>npx @acala-network/chopsticks\n</code></pre>"},{"location":"dev-tools/chopsticks/overview/#configuration","title":"Configuration","text":"<p>To run Chopsticks, you need to configure some parameters. This can be set either through using a configuration file or the command line interface (CLI). The parameters that can be configured are as follows:</p> <ul> <li><code>genesis</code> - the link to a parachain's raw genesis file to build the fork from, instead of an endpoint</li> <li><code>timestamp</code> - timestamp of the block to fork from</li> <li><code>endpoint</code> - the endpoint of the parachain to fork</li> <li><code>block</code> - use to specify at which block hash or number to replay the fork</li> <li><code>wasm-override</code> - path of the Wasm to use as the parachain runtime, instead of an endpoint's runtime</li> <li><code>db</code> - path to the name of the file that stores or will store the parachain's database</li> <li><code>config</code> - path or URL of the config file</li> <li><code>port</code> - the port to expose an endpoint on</li> <li><code>build-block-mode</code> - how blocks should be built in the fork: batch, manual, instant</li> <li><code>import-storage</code> - a pre-defined JSON/YAML storage path to override in the parachain's storage</li> <li><code>allow-unresolved-imports</code> - whether to allow Wasm unresolved imports when using a Wasm to build the parachain</li> <li><code>html</code> - include to generate storage diff preview between blocks</li> <li><code>mock-signature-host</code> - mock signature host so that any signature starts with <code>0xdeadbeef</code> and filled by <code>0xcd</code> is considered valid</li> </ul>"},{"location":"dev-tools/chopsticks/overview/#using-a-configuration-file","title":"Using a Configuration File","text":"<p>The Chopsticks source repository includes a collection of YAML files that can be used to set up various Substrate chains locally. You can download these configuration files from the repository's <code>configs</code> folder.</p> <p>An example of a configuration file for Polkadot is as follows:</p> <pre><code>endpoint:\n  - wss://rpc.ibp.network/polkadot\n  - wss://polkadot-rpc.dwellir.com\nmock-signature-host: true\nblock: ${env.POLKADOT_BLOCK_NUMBER}\ndb: ./db.sqlite\nruntime-log-level: 5\n\nimport-storage:\n  System:\n    Account:\n      - - - 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\n        - providers: 1\n          data:\n            free: '10000000000000000000'\n  ParasDisputes:\n    $removePrefix: ['disputes'] # those can makes block building super slow\n</code></pre> <p>To run Chopsticks using a configuration file, utilize the <code>--config</code> flag. You can use a raw GitHub URL, a path to a local file, or simply the chain's name. For example, the following commands all use Polkadot's configuration in the same way:</p> GitHub URLLocal File PathChain Name <pre><code>npx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks --config=configs/polkadot.yml\n</code></pre> <pre><code>npx @acala-network/chopsticks --config=polkadot\n</code></pre> <p>Regardless of which method you choose from the preceding examples, you'll see an output similar to the following:</p> npx @acala-network/chopsticks --config=polkadot [18:38:26.155] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata         chopsticks::executor  TRACE: Completed Metadata_metadata [18:38:28.186] INFO: Polkadot RPC listening on port 8000     app: \"chopsticks\" <p>Note</p> <p>If using a file path, make sure you've downloaded the Polkadot configuration file, or have created your own.</p>"},{"location":"dev-tools/chopsticks/overview/#using-command-line-interface-cli","title":"Using Command Line Interface (CLI)","text":"<p>Alternatively, all settings (except for genesis and timestamp) can be configured via command-line flags, providing a comprehensive method to set up the environment. For example, the following command forks Polkadot at block 100.</p> <pre><code>npx @acala-network/chopsticks \\\n--endpoint wss://polkadot-rpc.dwellir.com \\\n--block 100\n</code></pre> npx @acala-network/chopsticks \\ --endpoint wss://polkadot-rpc.dwellir.com \\ --block 100 [19:12:21.023] INFO: Polkadot RPC listening on port 8000     app: \"chopsticks\""},{"location":"dev-tools/chopsticks/overview/#interacting-with-a-fork","title":"Interacting with a Fork","text":"<p>When running a fork, it's accessible by default at:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>You can interact with the forked chain using various libraries such as Polkadot.js and its user interface, Polkadot.js Apps.</p>"},{"location":"dev-tools/chopsticks/overview/#using-polkadotjs-apps","title":"Using Polkadot.js Apps","text":"<p>To interact with Chopsticks via the hosted user interface, visit Polkadot.js Apps and follow these steps:</p> <ol> <li> <p>Click the network icon in the top left corner</p> <p></p> </li> <li> <p>Scroll to the bottom and select Development</p> </li> <li>Choose Custom</li> <li>Enter <code>ws://localhost:8000</code> in the input field</li> <li>Click the Switch button</li> </ol> <p></p> <p>You should now be connected to your local fork and can interact with it as you would with a real chain.</p>"},{"location":"dev-tools/chopsticks/overview/#using-polkadotjs-library","title":"Using Polkadot.js Library","text":"<p>For programmatic interaction, you can use the Polkadot.js library. Here's a basic example:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function connectToFork() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n\n  // Now you can use 'api' to interact with your fork\n  console.log(`Connected to chain: ${await api.rpc.system.chain()}`);\n}\n\nconnectToFork();\n</code></pre>"},{"location":"dev-tools/chopsticks/overview/#replaying-blocks","title":"Replaying Blocks","text":"<p>Chopsticks allows you to replay specific blocks from a chain, which is useful for debugging and analyzing state changes. You can use the parameters in the Configuration section to set up the chain configuration, and then use the run-block subcommand with additional options:</p> <ul> <li><code>output-path</code> - path to print output</li> <li><code>html</code> - generate HTML with storage diff</li> <li><code>open</code> - open generated HTML</li> </ul> <p>For example, to replay block 1000 from Polkadot and save the output to a JSON file:</p> <pre><code>npx @acala-network/chopsticks run-block  \\\n--endpoint wss://polkadot-rpc.dwellir.com  \\\n--output-path ./polkadot-output.json  \\\n--block 1000\n</code></pre> Output file content <pre><code>{\n    \"Call\": {\n        \"result\": \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44a10f6fc59a4d90c3b78e38fac100fc6adc6f9e69a07565ec8abce6165bd0d24078cc7bf34f450a2cc7faacc1fa1e244b959f0ed65437f44208876e1e5eefbf8dd34c040642414245b501030100000083e2cc0f00000000d889565422338aa58c0fd8ebac32234149c7ce1f22ac2447a02ef059b58d4430ca96ba18fbf27d06fe92ec86d8b348ef42f6d34435c791b952018d0a82cae40decfe5faf56203d88fdedee7b25f04b63f41f23da88c76c876db5c264dad2f70c\",\n        \"storageDiff\": [\n            [\n                \"0x0b76934f4cc08dee01012d059e1b83eebbd108c4899964f707fdaffb82636065\",\n                \"0x00\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f0323475657e0890fbdbf66fb24b4649e\",\n                null\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f06155b3cd9a8c9e5e9a23fd5dc13a5ed\",\n                \"0x83e2cc0f00000000\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087ffa92de910a7ce2bd58e99729c69727c1\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\",\n                \"0x02000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef734abf5cb34d6244378cddbf18e849d96\",\n                \"0xc03b86ae010000000000000000000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\",\n                \"0x080000000000000080e36a09000000000200000001000000000000ca9a3b00000000020000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef78a42f33323cb5ced3b44dd825fda9fcc\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef799e7f93fc6a98f0874fd057f111c4d2d\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a44704b568d21667356a5a050c118746d366e7fe86e06375e7030000\",\n                \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a86da5a932684f199539836fcb8c886f\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7b06c3320c6ac196d813442e270868d63\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7bdc0bd303e9855813aa8a30d4efc5112\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d15153cb1f00942ff401000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d1b4def25cfda6ef3a00000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\",\n                null\n            ],\n            [\n                \"0x2b06af9719ac64d755623cda8ddd9b94b1c371ded9e9c565e89ba783c4d5f5f9b4def25cfda6ef3a000000006f3d6b177c8acbd8dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e7201\",\n                \"0x9b000000\"\n            ],\n            [\n                \"0x3a65787472696e7369635f696e646578\",\n                null\n            ],\n            [\n                \"0x3f1467a096bcd71a5b6a0c8155e208103f2edf3bdf381debe331ab7446addfdc\",\n                \"0x550057381efedcffffffffffffffffff\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab0f41321f75df7ea5127be2db4983c8b2\",\n                \"0x00\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab21a5051453bd3ae7ed269190f4653f3b\",\n                \"0x080000\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790abb984cfb497221deefcefb70073dcaac1\",\n                \"0x00\"\n            ],\n            [\n                \"0x5f3e4907f716ac89b6347d15ececedca80cc6574281671b299c1727d7ac68cabb4def25cfda6ef3a00000000\",\n                \"0x204e0000183887050ecff59f58658b3df63a16d03a00f92890f1517f48c2f6ccd215e5450e380e00005809fd84af6483070acbb92378e3498dbc02fb47f8e97f006bb83f60d7b2b15d980d000082104c22c383925323bf209d771dec6e1388285abe22c22d50de968467e0bb6ce00b000088ee494d719d68a18aade04903839ea37b6be99552ceceb530674b237afa9166480d0000dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e72011c0c0000e240d12c7ad07bb0e7785ee6837095ddeebb7aef84d6ed7ea87da197805b343a0c0d0000\"\n            ],\n            [\n                \"0xae394d879ddf7f99595bc0dd36e355b5bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xbd2a529379475088d3e29a918cd478721a39ec767bd5269111e6492a1675702a\",\n                \"0x4501407565175cfbb5dca18a71e2433f838a3d946ef532c7bff041685db1a7c13d74252fffe343a960ef84b15187ea0276687d8cb3168aeea5202ea6d651cb646517102b81ff629ee6122430db98f2cadf09db7f298b49589b265dae833900f24baa8fb358d87e12f3e9f7986a9bf920c2fb48ce29886199646d2d12c6472952519463e80b411adef7e422a1595f1c1af4b5dd9b30996fba31fa6a30bd94d2022d6b35c8bc5a8a51161d47980bf4873e01d15afc364f8939a6ce5a09454ab7f2dd53bf4ee59f2c418e85aa6eb764ad218d0097fb656900c3bdd859771858f87bf7f06fc9b6db154e65d50d28e8b2374898f4f519517cd0bedc05814e0f5297dc04beb307b296a93cc14d53afb122769dfd402166568d8912a4dff9c2b1d4b6b34d811b40e5f3763e5f3ab5cd1da60d75c0ff3c12bcef3639f5f792a85709a29b752ffd1233c2ccae88ed3364843e2fa92bdb49021ee36b36c7cdc91b3e9ad32b9216082b6a2728fccd191a5cd43896f7e98460859ca59afbf7c7d93cd48da96866f983f5ff8e9ace6f47ee3e6c6edb074f578efbfb0907673ebca82a7e1805bc5c01cd2fa5a563777feeb84181654b7b738847c8e48d4f575c435ad798aec01631e03cf30fe94016752b5f087f05adf1713910767b7b0e6521013be5370776471191641c282fdfe7b7ccf3b2b100a83085cd3af2b0ad4ab3479448e71fc44ff987ec3a26be48161974b507fb3bc8ad23838f2d0c54c9685de67dc6256e71e739e9802d0e6e3b456f6dca75600bc04a19b3cc1605784f46595bfb10d5e077ce9602ae3820436166aa1905a7686b31a32d6809686462bc9591c0bc82d9e49825e5c68352d76f1ac6e527d8ac02db3213815080afad4c2ecb95b0386e3e9ab13d4f538771dac70d3059bd75a33d0b9b581ec33bb16d0e944355d4718daccb35553012adfcdacb1c5200a2aec3756f6ad5a2beffd30018c439c1b0c4c0f86dbf19d0ad59b1c9efb7fe90906febdb9001af1e7e15101089c1ab648b199a40794d30fe387894db25e614b23e833291a604d07eec2ade461b9b139d51f9b7e88475f16d6d23de6fe7831cc1dbba0da5efb22e3b26cd2732f45a2f9a5d52b6d6eaa38782357d9ae374132d647ef60816d5c98e6959f8858cfa674c8b0d340a8f607a68398a91b3a965585cc91e46d600b1310b8f59c65b7c19e9d14864a83c4ad6fa4ba1f75bba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44c7736fc3ab2969878810153aa3c93fc08c99c478ed1bb57f647d3eb02f25cee122c70424643f4b106a7643acaa630a5c4ac39364c3cb14453055170c01b44e8b1ef007c7727494411958932ae8b3e0f80d67eec8e94dd2ff7bbe8c9e51ba7e27d50bd9f52cbaf9742edecb6c8af1aaf3e7c31542f7d946b52e0c37d194b3dd13c3fddd39db0749755c7044b3db1143a027ad428345d930afcefc0d03c3a0217147900bdea1f5830d826f7e75ecd1c4e2bc8fd7de3b35c6409acae1b2215e9e4fd7e360d6825dc712cbf9d87ae0fd4b349b624d19254e74331d66a39657da81e73d7b13adc1e5efa8efd65aa32c1a0a0315913166a590ae551c395c476116156cf9d872fd863893edb41774f33438161f9b973e3043f819d087ba18a0f1965e189012496b691f342f7618fa9db74e8089d4486c8bd1993efd30ff119976f5cc0558e29b417115f60fd8897e13b6de1a48fbeee38ed812fd267ae25bffea0caa71c09309899b34235676d5573a8c3cf994a3d7f0a5dbd57ab614c6caf2afa2e1a860c6307d6d9341884f1b16ef22945863335bb4af56e5ef5e239a55dbd449a4d4d3555c8a3ec5bd3260f88cabca88385fe57920d2d2dfc5d70812a8934af5691da5b91206e29df60065a94a0a8178d118f1f7baf768d934337f570f5ec68427506391f51ab4802c666cc1749a84b5773b948fcbe460534ed0e8d48a15c149d27d67deb8ea637c4cc28240ee829c386366a0b1d6a275763100da95374e46528a0adefd4510c38c77871e66aeda6b6bfd629d32af9b2fad36d392a1de23a683b7afd13d1e3d45dad97c740106a71ee308d8d0f94f6771164158c6cd3715e72ccfbc49a9cc49f21ead8a3c5795d64e95c15348c6bf8571478650192e52e96dd58f95ec2c0fb4f2ccc05b0ab749197db8d6d1c6de07d6e8cb2620d5c308881d1059b50ffef3947c273eaed7e56c73848e0809c4bd93619edd9fd08c8c5c88d5f230a55d2c6a354e5dd94440e7b5bf99326cf4a112fe843e7efdea56e97af845761d98f40ed2447bd04a424976fcf0fe0a0c72b97619f85cf431fe4c3aa6b3a4f61df8bc1179c11e77783bfedb7d374bd1668d0969333cb518bd20add8329462f2c9a9f04d150d60413fdd27271586405fd85048481fc2ae25b6826cb2c947e4231dc7b9a0d02a9a03f88460bced3fef5d78f732684bd218a1954a4acfc237d79ccf397913ab6864cd8a07e275b82a8a72520624738368d1c5f7e0eaa2b445cf6159f2081d3483618f7fc7b16ec4e6e4d67ab5541bcda0ca1af40efd77ef8653e223191448631a8108c5e50e340cd405767ecf932c1015aa8856b834143dc81fa0e8b9d1d8c32278fca390f2ff08181df0b74e2d13c9b7b1d85543416a0dae3a77530b9cd1366213fcf3cd12a9cd3ae0a006d6b29b5ffc5cdc1ab24343e2ab882abfd719892fca5bf2134731332c5d3bef6c6e4013d84a853cb03d972146b655f0f8541bcd36c3c0c8a775bb606edfe50d07a5047fd0fe01eb125e83673930bc89e91609fd6dfe97132679374d3de4a0b3db8d3f76f31bed53e247da591401d508d65f9ee01d3511ee70e3644f3ab5d333ca7dbf737fe75217b4582d50d98b5d59098ea11627b7ed3e3e6ee3012eadd326cf74ec77192e98619427eb0591e949bf314db0fb932ed8be58258fb4f08e0ccd2cd18b997fb5cf50c90d5df66a9f3bb203bd22061956128b800e0157528d45c7f7208c65d0592ad846a711fa3c5601d81bb318a45cc1313b122d4361a7d7a954645b04667ff3f81d3366109772a41f66ece09eb93130abe04f2a51bb30e767dd37ec6ee6a342a4969b8b342f841193f4f6a9f0fac4611bc31b6cab1d25262feb31db0b8889b6f8d78be23f033994f2d3e18e00f3b0218101e1a7082782aa3680efc8502e1536c30c8c336b06ae936e2bcf9bbfb20dd514ed2867c03d4f44954867c97db35677d30760f37622b85089cc5d182a89e29ab0c6b9ef18138b16ab91d59c2312884172afa4874e6989172014168d3ed8db3d9522d6cbd631d581d166787c93209bec845d112e0cbd825f6df8b64363411270921837cfb2f9e7f2e74cdb9cd0d2b02058e5efd9583e2651239654b887ea36ce9537c392fc5dfca8c5a0facbe95b87dfc4232f229bd12e67937d32b7ffae2e837687d2d292c08ff6194a2256b17254748857c7e3c871c3fff380115e6f7faf435a430edf9f8a589f6711720cfc5cec6c8d0d94886a39bb9ac6c50b2e8ef6cf860415192ca4c1c3aaa97d36394021a62164d5a63975bcd84b8e6d74f361c17101e3808b4d8c31d1ee1a5cf3a2feda1ca2c0fd5a50edc9d95e09fb5158c9f9b0eb5e2c90a47deb0459cea593201ae7597e2e9245aa5848680f546256f3\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5e326d21bc67a4b34023d577585d72bfd7\",\n                null\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ea36180b5cfb9f6541f8849df92a6ec93\",\n                \"0x00\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ebddf84c5eb23e6f53af725880d8ffe90\",\n                null\n            ],\n            [\n                \"0xd5c41b52a371aa36c9254ce34324f2a53b996bb988ea8ee15bad3ffd2f68dbda\",\n                \"0x00\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c49f1f0515f462cdcf84e0f1d6045dfcbb\",\n                \"0x50defc5172010000\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c4bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed90420d49a14a763e1cbc887acd097f92014\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed9049b58374218f48eaf5bc23b7b3e7cf08a\",\n                \"0xb3030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed904b97380ce5f4e70fbf9d6b5866eb59527\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ]\n        ],\n        \"offchainStorageDiff\": [],\n        \"runtimeLogs\": []\n    }\n}\n</code></pre>"},{"location":"dev-tools/chopsticks/overview/#xcm-testing","title":"XCM Testing","text":"<p>To test XCM (Cross-Consensus Messaging) messages between networks, you can fork multiple parachains and a relay chain locally using Chopsticks.</p> <ul> <li><code>relaychain</code> - relay chain config file</li> <li><code>parachain</code> - parachain config file  </li> </ul> <p>For example, to fork Moonbeam, Astar, and Polkadot enabling XCM between them, you can use the following command:</p> <pre><code>npx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p moonbeam \\\n--p astar\n</code></pre> <p>After running it, you should see output similar to the following:</p> npx @acala-network/chopsticks xcm \\ --r polkadot \\ --p moonbeam \\ --p astar [13:46:07.901] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml     app: \"chopsticks\" [13:46:12.631] INFO: Moonbeam RPC listening on port 8000     app: \"chopsticks\" [13:46:12.632] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/astar.yml     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata         chopsticks::executor  TRACE: Completed Metadata_metadata [13:46:23.669] INFO: Astar RPC listening on port 8001     app: \"chopsticks\" [13:46:25.144] INFO (xcm): Connected parachains [2004,2006]     app: \"chopsticks\" [13:46:25.144] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml     app: \"chopsticks\"         chopsticks::executor  TRACE: Calling Metadata_metadata         chopsticks::executor  TRACE: Completed Metadata_metadata [13:46:53.320] INFO: Polkadot RPC listening on port 8002     app: \"chopsticks\" [13:46:54.038] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Moonbeam'     app: \"chopsticks\" [13:46:55.028] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Astar'     app: \"chopsticks\" <p>Now you can interact with your forked chains using the ports specified in the output.</p>"},{"location":"dev-tools/chopsticks/overview/#websocket-commands","title":"WebSocket Commands","text":"<p>Chopstick's internal WebSocket server has special endpoints that allow the manipulation of the local Substrate chain.</p> <p>These are the methods that can be invoked and their parameters:</p> dev_newBlock (newBlockParams) \u2014 Generates one or more new blocks ParametersExample <ul> <li><code>newBlockParams</code> NewBlockParams  - the parameters to build the new block with. Where the <code>NewBlockParams</code> interface includes the following properties:<ul> <li><code>count</code> number - the number of blocks to build</li> <li><code>dmp</code> { msg: string, sentAt: number }[] - the downward messages to include in the block</li> <li><code>hrmp</code> Record&lt;string | number, { data: string, sentAt: number }[]&gt; - the horizontal messages to include in the block</li> <li><code>to</code> number - the block number to build to</li> <li><code>transactions</code> string[] - the transactions to include in the block</li> <li><code>ump</code> Record&lt;number, string[]&gt; - the upward messages to include in the block</li> <li><code>unsafeBlockHeight</code> number - build block using a specific block height (unsafe)</li> </ul> </li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_newBlock', { count: 1 });\n}\n\nmain();\n</code></pre> dev_setBlockBuildMode (buildBlockMode) \u2014 Sets block build mode ParameterExample <ul> <li><code>buildBlockMode</code> BuildBlockMode - the build mode. Can be any of the following modes:     <pre><code>export enum BuildBlockMode {\n  Batch = 'Batch', /** One block per batch (default) */\n  Instant = 'Instant', /** One block per transaction */\n  Manual = 'Manual', /** Only build when triggered */\n}\n</code></pre></li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setBlockBuildMode', 'Instant');\n}\n\nmain();\n</code></pre> dev_setHead (hashOrNumber) \u2014 Sets the head of the blockchain to a specific hash or number ParameterExample <ul> <li><code>hashOrNumber</code> string | number - the block hash or number to set as head</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setHead', 500);\n}\n\nmain();\n</code></pre> dev_setRuntimeLogLevel (runtimeLogLevel) \u2014 Sets the runtime log level ParameterExample <ul> <li><code>runtimeLogLevel</code> number - the runtime log level to set</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_setRuntimeLogLevel', 1);\n}\n\nmain();\n</code></pre> dev_setStorage (values, blockHash) \u2014 Creates or overwrites the value of any storage ParametersExample <ul> <li><code>values</code> object - JSON object resembling the path to a storage value</li> <li><code>blockHash</code> string - the block hash to set the storage value</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nimport { Keyring } from '@polkadot/keyring';\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  const keyring = new Keyring({ type: 'ed25519' });\n  const bob = keyring.addFromUri('//Bob');\n  const storage = {\n    System: {\n      Account: [[[bob.address], { data: { free: 100000 }, nonce: 1 }]],\n    },\n  };\n  await api.rpc('dev_setStorage', storage);\n}\n\nmain();\n</code></pre> dev_timeTravel (date) \u2014 Sets the timestamp of the block to a specific date ParameterExample <ul> <li><code>date</code> string - timestamp or date string to set. All future blocks will be sequentially created after this point in time</li> </ul> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n  await api.rpc('dev_timeTravel', '2030-08-15T00:00:00');\n}\n\nmain();\n</code></pre>"},{"location":"dev-tools/zombienet/overview/","title":"Zombienet","text":""},{"location":"dev-tools/zombienet/overview/#introduction","title":"Introduction","text":"<p>Zombienet is a testing framework designed for Polkadot SDK-based blockchains. It provides a simple CLI tool for creating and testing blockchain environments locally or across networks. This allows developers to easily run and interact with blockchain nodes in a controlled environment. Zombienet is a\u00a0JavaScript\u00a0library designed to run on\u00a0Node.js\u00a0and supports various backend providers, including Kubernetes, Podman, and local setups for running blockchain nodes.</p> <p>The framework enables developers to create tests using natural language tools to verify on-chain storage, metrics, logs, and custom interactions with the blockchain. It is particularly effective for setting up local relaychains with validators and parachains with collators.</p> <p>Parity Technologies has designed and developed this framework, now maintained by the Zombienet team. For further support and information, refer to the following contact points:</p> <ul> <li>Zombienet repository</li> <li>Element public channel</li> </ul>"},{"location":"dev-tools/zombienet/overview/#install-zombienet","title":"Install Zombienet","text":"<p>Zombienet releases are available on the Zombienet repository.</p> <p>In order to install Zombienet, there are multiple options available, depending on the user's preferences and the environment where it will be used. The following section will guide you through the installation process for each of the available options.</p> Using the ExecutableUsing NixUsing Docker <p>Zombienet executables can be downloaded using the latest release uploaded on the Zombienet repository. You can download the executable for your operating system and architecture and then move it to a directory in your PATH. Each release includes executables for Linux and macOS, which are generated using pkg. This allows the Zombienet CLI to operate without requiring Node.js to be installed. </p> <p>Alternatively, you can also download the executable using either <code>curl</code> or <code>wget</code>:</p> curlwget <pre><code>curl -LO \\\nhttps://github.com/paritytech/zombienet/releases/download/&lt;INSERT_ZOMBIENET_VERSION&gt;/&lt;INSERT_ZOMBIENET_EXECUTABLE&gt;\n</code></pre> <pre><code>wget \\\nhttps://github.com/paritytech/zombienet/releases/download/&lt;INSERT_ZOMBIENET_VERSION&gt;/&lt;INSERT_ZOMBIENET_EXECUTABLE&gt;\n</code></pre> <p>Note</p> <p>Ensure to replace the URL with the <code>&lt;INSERT_ZOMBIENET_VERSION&gt;</code> that you want to download, as well as the <code>&lt;INSERT_ZOMBIENET_EXECUTABLE&gt;</code> with the name of the executable file that matches your operating system and architecture. This guide uses <code>v1.3.106</code> and <code>zombienet-macos-arm64</code>.</p> <p>Note</p> <p>This documentation explains the functionality of Chopsticks version <code>0.13.1</code>. Make sure you're using the correct version to match these instructions.</p> <p>Then, ensure the downloaded file is executable:</p> <pre><code>chmod +x zombienet-macos-arm64\n</code></pre> <p>Finally, you can run the following command to check if the installation was successful. If so, it will display the version of the installed Zombienet:</p> <pre><code>./zombienet-macos-arm64 version\n</code></pre> <p>If you want to add the <code>zombienet</code> executable to your PATH, you can move it to a directory in your PATH, such as <code>/usr/local/bin</code>:</p> <pre><code>mv zombienet-macos-arm64 /usr/local/bin/zombienet\n</code></pre> <p>So then, you can refer to the <code>zombienet</code> executable directly:</p> <pre><code>zombienet version\n</code></pre> <p>So then, you can refer to the <code>zombienet</code> executable directly:</p> <pre><code>zombienet version\n</code></pre> <p>For Nix users, the Zombienet repository provides a <code>flake.nix</code> file that can be used to install Zombienet. This means that users can easily incorporate Zombienet into their Nix-based projects. </p> <p>To install Zombienet utilizing Nix, users can run the following command, triggering the fetching of the flake and subsequently installing the Zombienet package:</p> <pre><code>nix run github:paritytech/zombienet/INSERT_ZOMBIENET_VERSION -- \\\nspawn INSERT_ZOMBIENET_CONFIG_FILE_NAME.toml\n</code></pre> <p>Note</p> <p>Ensure to replace the <code>INSERT_ZOMBIENET_VERSION</code> with the desired version of Zombienet. Also, replace the <code>INSERT_ZOMBIENET_CONFIG_FILE_NAME</code> with the name of the configuration file you want to use.</p> <p>To run the command above, you need to have Flakes enabled.</p> <p>Alternatively, you can also include the Zombienet binary in the PATH for the current shell. This can be achieved by:</p> <pre><code>nix shell github:paritytech/zombienet/INSERT_ZOMBIENET_VERSION\n</code></pre> <p>Zombienet can also be run using Docker. The Zombienet repository provides a Docker image that can be used to run the Zombienet CLI. To run Zombienet using Docker, you can use the following command:</p> <p><pre><code>docker run -it --rm \\\n-v $(pwd):/home/nonroot/zombie-net/host-current-files \\\nparitytech/zombienet\n</code></pre> The command above will run the Zombienet CLI inside a Docker container and mount the current directory to the <code>/home/nonroot/zombie-net/host-current-files</code> directory inside the container. This allows Zombienet to access the configuration file and other files in the current directory. If you want to mount a different directory, replace <code>$(pwd)</code> with the desired directory path.</p> <p>Inside the Docker container, you can run the Zombienet CLI commands. First, you need to set up Zombienet downloading the necessary binaries:</p> <pre><code>npm run zombie -- setup polkadot polkadot-parachain\n</code></pre> <p>After that, you need to add those binaries to the PATH:</p> <pre><code>export PATH=/home/nonroot/zombie-net:$PATH\n</code></pre> <p>Finally, you can run the Zombienet CLI commands. For example, to spawn a network using a specific configuration file, you can run the following command:</p> <pre><code>npm run zombie -- -p native spawn host-current-files/minimal.toml\n</code></pre> <p>The command above mounts the current directory to the <code>/workspace</code> directory inside the Docker container. This allows Zombienet to access the configuration file and other files in the current directory. If you want to mount a different directory, replace <code>$(pwd)</code> with the desired directory path.</p>"},{"location":"dev-tools/zombienet/overview/#providers","title":"Providers","text":"<p>Zombienet supports different backend\u00a0providers\u00a0for running the\u00a0nodes. At this moment, Kubernetes,\u00a0Podman, and\u00a0local\u00a0are supported, which can be declared as <code>kubernetes</code>, <code>podman</code>, or <code>native</code>, respectively.</p> <p>To use a particular provider, you can specify it in the network file or use the <code>--provider</code> flag in the CLI:</p> <pre><code>zombienet spawn network.toml --provider INSERT_PROVIDER\n</code></pre> <p>Alternatively, you can set the provider in the network file:</p> <pre><code>[settings]\nprovider = \"INSERT_PROVIDER\"\n...\n</code></pre> <p>At the moment, Zombienet supports the following providers: <code>kubernetes</code>, <code>podman</code>, and <code>native</code>.</p> <p>It's important to note that each provider has specific requirements and associated features. The subsequent sections will guide you through the installation process for each provider and the requirements and features each provider offers.</p>"},{"location":"dev-tools/zombienet/overview/#kubernetes","title":"Kubernetes","text":""},{"location":"dev-tools/zombienet/overview/#requirements","title":"Requirements","text":"<p>Zombienet is designed to be compatible with a variety of Kubernetes clusters, including Google Kubernetes Engine (GKE), Docker Desktop, and kind. To effectively interact with your cluster, you'll need to ensure that <code>kubectl</code> is installed on your system, which is the Kubernetes command-line tool that allows you to run commands against Kubernetes clusters. If you don't have <code>kubectl</code> installed, you can follow the instructions provided on the Kubernetes website.</p> <p>Moreover, in order to create resources such as namespaces, pods, and CronJobs within the target cluster, you must have the appropriate permissions granted to your user or service account. These permissions are essential for managing and deploying applications effectively within Kubernetes.</p>"},{"location":"dev-tools/zombienet/overview/#features","title":"Features","text":"<p>In Kubernetes, Zombienet uses the Prometheus operator (if available) to oversee monitoring and visibility. This configuration ensures that only essential networking-related pods are deployed. Using the Prometheus operator, Zombienet improves its ability to efficiently monitor and manage network activities within the Kubernetes cluster. </p>"},{"location":"dev-tools/zombienet/overview/#podman","title":"Podman","text":""},{"location":"dev-tools/zombienet/overview/#requirements_1","title":"Requirements","text":"<p>Zombienet supports Podman rootless as a provider. To use Podman as a provider, you need to have Podman installed on your system. Podman is a daemonless container engine for developing, managing, and running Open Container Initiative (OCI) containers and container images on Linux-based systems. You can install Podman by following the instructions provided on the Podman website.</p> <p>Warning</p> <p>Currently, Podman can only be used with Zombienet on Linux machines. Although Podman has support for macOS through an internal VM, the Zombienet provider code requires Podman to run natively on Linux.</p>"},{"location":"dev-tools/zombienet/overview/#features_1","title":"Features","text":"<p>Using Podman, Zombienet deploys additional pods to enhance the monitoring and visibility of the active network. Specifically, pods for Prometheus, Tempo, and Grafana are included in the deployment. Grafana is configured with Prometheus and Tempo as data sources.</p> <p>Upon launching Zombienet, access to these monitoring services is facilitated through specific URLs provided in the output:</p> <ul> <li>Prometheus - http://127.0.0.1:34123</li> <li>Tempo - http://127.0.0.1:34125</li> <li>Grafana - http://127.0.0.1:41461</li> </ul> <p>It's important to note that Grafana is deployed with default administrator access.</p> <p>Note</p> <p>When network operations cease \u2014either by halting a running spawn with Ctrl+C or upon completion of the test\u2014 Zombienet automatically removes all associated pods.</p>"},{"location":"dev-tools/zombienet/overview/#local","title":"Local","text":""},{"location":"dev-tools/zombienet/overview/#requirements_2","title":"Requirements","text":"<p>The Zombienet local provider, also referred to as native, enables you to run nodes as local processes in your environment. You must have the necessary binaries for your network (such as <code>polkadot</code> and <code>polkadot-parachain</code>). These binaries should be available in your PATH, allowing Zombienet to spawn the nodes as local processes.</p> <p>To install the necessary binaries, you can use the Zombienet CLI command:</p> <pre><code>zombienet setup polkadot polkadot-parachain\n</code></pre> <p>This command will download and prepare the necessary binaries for Zombienet\u2019s use.</p> <p>Warning</p> <p>The <code>polkadot</code> and <code>polkadot-parachain</code> binaries releases are not compatible with macOS. As a result, macOS users will need to clone the Polkadot repository, build the Polkadot binary, and manually add it to their PATH for <code>polkadot</code> and <code>polkadot-parachain</code> to work.</p> <p>If you need to use a custom binary, ensure the binary is available in your PATH. You can also specify the binary path in the network configuration file. To showcase this, this guide will use the custom OpenZeppelin template as an example.</p> <p>First, clone the OpenZeppelin template repository:</p> <pre><code>git clone https://github.com/OpenZeppelin/polkadot-runtime-templates \\\n&amp;&amp; cd polkadot-runtime-templates/generic-template\n\nThen, build the custom binary:\n\n```bash\ncargo build --release\n</code></pre> <p>After that, add the custom binary to your PATH:</p> <pre><code>export PATH=$PATH:/path/to/polkadot-runtime-templates/parachain-template-node/target/release\n</code></pre> <p>Alternatively, you can specify the binary path in the network configuration file:</p> <pre><code>[relaychain]\nchain = \"rococo-local\"\ndefault_command = \"./bin-v1.6.0/polkadot\"\n\n[parachain]\nid = 1000\n\n    [parachain.collators]\n    name = \"collator01\"\n    command = \"./target/release/parachain-template-node\"\n</code></pre> <p>Note</p> <p>The local provider exclusively utilizes the command configuration for nodes/collators, which supports both relative and absolute paths. You can employ the <code>default_command</code> configuration to specify the binary for spawning all nodes in the relay chain.</p>"},{"location":"dev-tools/zombienet/overview/#features_2","title":"Features","text":"<p>Currently, the local provider does not execute any additional layers or processes.</p>"},{"location":"dev-tools/zombienet/overview/#cli-usage","title":"CLI Usage","text":"<p>Zombienet provides a CLI that allows interaction with the tool. The CLI can receive commands and flags to perform different kinds of operations. These operations can be initiated using the following syntax:</p> <pre><code>zombienet &lt;arguments&gt; &lt;commands&gt;\n</code></pre> <p>The following sections will guide you through the primary usage of the Zombienet CLI and the available commands and flags.</p>"},{"location":"dev-tools/zombienet/overview/#cli-commands","title":"CLI Commands","text":"<code>spawn</code> - spawn the network defined in the configuration file Argument <ul> <li><code>&lt;networkConfig&gt;</code> - a file that declares the desired network to be spawned in <code>.toml</code> or <code>.json</code> format. For further information, check out the Configuration Files section</li> </ul> <p>Warning</p> <p>For the <code>spawn</code> command to work on macOS, users need to be aware that the Polkadot binary is currently not compatible with macOS. As a result, macOS users will need to clone the Polkadot repository, build Polkadot binary, and manually add it to their PATH.</p> <code>test</code> - run test on the network spawned Argument <ul> <li><code>&lt;testFile&gt;</code> - a file that defines assertions and tests against the spawned network, using natural language expressions to evaluate metrics, logs, and built-in functions</li> </ul> <code>setup</code> - set up the Zombienet development environment Argument <ul> <li><code>&lt;binaries&gt;</code> - executables that will be downloaded and prepared to be used by Zombienet. Options: <code>polkadot</code>, <code>polkadot-parachain</code></li> </ul> <code>convert</code> - transforms a (now deprecated) polkadot-launch configuration file to a Zombienet configuration file Argument <ul> <li><code>&lt;filePath&gt;</code> - path to a polkadot-launch configuration file with a <code>.js</code> or <code>.json</code> extension defined by the <code>LaunchConfig</code> interface</li> </ul> <code>version</code> - prints Zombienet version Argument <p>None </p> <code>help</code> - prints help information Argument <p>None </p>"},{"location":"dev-tools/zombienet/overview/#cli-flags","title":"CLI Flags","text":"<p>You can use the following flags to customize the behavior of the CLI:</p> <code>-p</code>, <code>--provider</code> - override provider to use. Defaults to <code>kubernetes</code> Argument <ul> <li><code>&lt;provider&gt;</code> - the provider to use. Options: <code>podman</code>, <code>kubernetes</code>, <code>native</code></li> </ul> <code>-d</code>, <code>--dir</code> - directory path for placing the network files instead of random temp one ArgumentExample <ul> <li><code>&lt;path&gt;</code> - desired path for network files  </li> </ul> <p><code>zombienet -d /home/user/my-zombienet</code></p> <code>-f</code>, <code>--force</code> - force override all prompt commands Argument <p>None</p> <code>-l</code>, <code>--logType</code> - type of logging on the console. Defaults to <code>table</code> Argument <ul> <li><code>&lt;logType&gt;</code> desired type of logging. Options: <code>table</code>, <code>text</code>, <code>silent</code></li> </ul> <code>-m</code>, <code>--monitor</code> - start as monitor, do not auto clean up network Argument <p>None</p> <code>-c</code>, <code>--spawn-concurrency</code> - number of concurrent spawning processes to launch. Defaults to <code>1</code> Argument <ul> <li><code>&lt;concurrency&gt;</code> - desired quantity of processes</li> </ul> <code>-h</code>, <code>--help</code> - display help for command Argument <p>None</p>"},{"location":"dev-tools/zombienet/overview/#configuration-files","title":"Configuration Files","text":"<p>The network configuration can be given in either JSON or TOML format. The Zombienet repository also provides a folder with some examples of configuration files that can be used as a reference.</p> <p>Note</p> <p>Each section may include provider-specific keys that are not recognized by other providers. For example, if you use the local provider, any references to images for nodes will be disregarded.</p>"},{"location":"dev-tools/zombienet/overview/#settings","title":"Settings","text":"<p>Through the keyword <code>settings</code>, it's possible to define the general settings for the network. The available keys are:</p> <ul> <li><code>global_volumes?</code> GlobalVolume[] - a list of global volumes to use. The <code>GlobalVolume</code> interface is defined as follows:    <pre><code>export interface GlobalVolume {\n  name: string;\n  fs_type: string;\n  mount_path: string;\n}\n</code></pre></li> <li><code>bootnode</code> boolean - add bootnode to network. Default is <code>true</code></li> <li><code>bootnode_domain?</code> string - domain to use for bootnode</li> <li><code>timeout</code> number - global timeout to use for spawning the whole network\"</li> <li><code>node_spawn_timeout?</code> number - timeout to spawn pod/process</li> <li><code>grafana?</code> boolean - deploy an instance of Grafana</li> <li><code>prometheus?</code> boolean - deploy an instance of Prometheus</li> <li><code>telemetry?</code> boolean - enable telemetry for the network</li> <li><code>jaeger_agent?</code> string - the Jaeger agent endpoint passed to the nodes. Only available on Kubernetes</li> <li><code>tracing_collator_url?</code> string - the URL of the tracing collator used to query by the tracing assertion. Should be tempo query compatible</li> <li><code>tracing_collator_service_name?</code> string - service name for tempo query frontend. Only available on Kubernetes. Defaults to <code>tempo-tempo-distributed-query-frontend</code></li> <li><code>tracing_collator_service_namespace?</code> string - namespace where tempo is running. Only available on Kubernetes. Defaults to <code>tempo</code></li> <li><code>tracing_collator_service_port?</code> number - port of the query instance of tempo. Only available on Kubernetes. Defaults to <code>3100</code></li> <li><code>enable_tracing?</code> boolean - enable the tracing system. Only available on Kubernetes. Defaults to <code>true</code></li> <li><code>provider</code> string - provider to use. Default is <code>kubernetes</code>\"</li> <li><code>polkadot_introspector?</code> boolean - deploy an instance of polkadot-introspector. Only available on Podman and Kubernetes. Defaults to <code>false</code></li> <li><code>backchannel?</code> boolean - deploy an instance of backchannel server. Only available on Kubernetes. Defaults to <code>false</code></li> <li><code>image_pull_policy?</code> string - image pull policy to use in the network. Possible values are <code>Always</code>, <code>IfNotPresent</code>, and <code>Never</code></li> <li><code>local_ip?</code> string - IP used for exposing local services (rpc/metrics/monitors). Defaults to <code>\"127.0.0.1\"</code></li> <li><code>global_delay_network_global_settings?</code> number - delay in seconds to apply to the network</li> <li><code>node_verifier?</code> string - specify how to verify node readiness or deactivate by using <code>None</code>. Possible values are <code>None</code> and <code>Metric</code>. Defaults to <code>Metric</code></li> </ul> <p>For example, the following configuration file defines a minimal example for the settings:</p> TOMLJSON base-example.toml<pre><code>[settings]\ntimeout = 1000\nbootnode = false\nprovider = \"kubernetes\"\nbackchannel = false\n...\n</code></pre> base-example.json<pre><code>{\n    \"settings\": {\n        \"timeout\": 1000,\n        \"bootnode\": false,\n        \"provider\": \"kubernetes\",\n        \"backchannel\": false,\n        ...\n    },\n    ...\n}\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#relay-chain-configuration","title":"Relay Chain Configuration","text":"<p>You can use the <code>relaychain</code> keyword to define further parameters for the relay chain at start-up. The available keys are:</p> <ul> <li><code>default_command?</code> string - the default command to run. Defaults to <code>polkadot</code></li> <li><code>default_image?</code> string - the default Docker image to use</li> <li><code>default_resources?</code> Resources - represents the resources limits/reservations needed by the nodes by default. Only available on Kubernetes. The <code>Resources</code> interface is defined as follows:   <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre></li> <li><code>default_db_snapshot?</code> string - the default database snapshot to use</li> <li><code>default_prometheus_prefix</code> string - a parameter for customizing the metric's prefix. Defaults to <code>substrate</code></li> <li><code>default_substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version. The <code>SubstrateCliArgsVersion</code> enum is defined as follows:   <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre></li> <li><code>default_keystore_key_types?</code> string[] - defines which keystore keys should be created </li> <li><code>chain</code> string - the chain name</li> <li><code>chain_spec_path?</code> string - path to the chain spec file. Should be the plain version to allow customizations</li> <li><code>chain_spec_command?</code> string - command to generate the chain spec. It can't be used in combination with <code>chain_spec_path</code></li> <li><code>default_args?</code> string[] - an array of arguments to use as default to pass to the command</li> <li><code>default_overrides?</code> Override[] - an array of overrides to upload to the node. The <code>Override</code> interface is defined as follows:   <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n} \n</code></pre></li> <li><code>random_nominators_count?</code> number - if set and the stacking pallet is enabled, Zombienet will generate the input quantity of nominators and inject them into the genesis</li> <li><code>max_nominations</code> number - the max number of nominations allowed by a nominator. Should match the value set in the runtime. Defaults to <code>24</code></li> <li><code>nodes?</code> Node[] - an array of nodes to spawn. It is further defined on the Node Configuration section</li> <li><code>node_groups?</code> NodeGroup[] - an array of node groups to spawn. It is further defined on the Node Group Configuration section</li> <li><code>total_node_in_group?</code> number - the total number of nodes in the group. Defaults to <code>1</code></li> <li><code>genesis</code> JSON - the genesis configuration</li> <li><code>default_delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> </ul>"},{"location":"dev-tools/zombienet/overview/#node-configuration","title":"Node Configuration","text":"<p>There is one specific key capable of receiving more subkeys: the <code>nodes</code> key. This key is used to define further parameters for the nodes. The available keys:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (e.g., <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>command_with_args?</code> string - override default command and arguments</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li><code>env?</code> envVars[] - environment variables to set in the container. The <code>envVars</code> interface is defined as follows:   <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre></li> <li><code>overrides?</code> Override[] - array of overrides definitions. The <code>Override</code> interface is defined as follows:   <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre></li> <li><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead. The <code>SubstrateCliArgsVersion</code> enum is defined as follows:   <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre></li> <li><code>resources?</code> Resources - represent the resources limits/reservations needed by the node. The <code>Resources</code> interface is defined as follows:   <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre></li> <li><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</li> <li><code>validator</code> boolean - pass the <code>--validator</code> flag to the command. Defaults to <code>true</code></li> <li><code>invulnerable</code> boolean - if true, add the node to invulnerables in the chain spec. Defaults to <code>false</code></li> <li><code>balance</code> number - balance to set in balances for node's account. Defaults to <code>2000000000000</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>add_to_bootnodes?</code> boolean - add this node to the bootnode list. Defaults to <code>false</code></li> <li><code>ws_port?</code> number - WS port to use</li> <li><code>rpc_port?</code> number - RPC port to use</li> <li><code>prometheus_port?</code> number - Prometheus port to use</li> <li><code>p2p_cert_hash?</code> string - libp2p certhash to use with webRTC transport</li> <li><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> </ul> <p>The following configuration file defines a minimal example for the relay chain, including the <code>nodes</code> key:</p> TOMLJSON relaychain-example-nodes.toml<pre><code>[relaychain]\ndefault_command = \"polkadot\"\ndefault_image = \"polkadot-debug:master\"\nchain = \"rococo-local\"\nchain_spec_path = \"/path/to/chain-spec.json\"\ndefault_args = [\"--chain\", \"rococo-local\"]\n\n[[relaychain.nodes]]\nname = \"alice\"\nvalidator = true\nbalance = 1000000000000\n\n[[relaychain.nodes]]\nname = \"bob\"\nvalidator = true\nbalance = 1000000000000\n...\n</code></pre> relaychain-example-nodes.json<pre><code>{\n    ...,\n    \"relaychain\": {\n        \"default_command\": \"polkadot\",\n        \"default_image\": \"polkadot-debug:master\",\n        \"chain\": \"rococo-local\",\n        \"chain_spec_path\": \"/path/to/chain-spec.json\",\n        \"default_args\": [\"--chain\", \"rococo-local\"],\n        \"nodes\": [\n            {\n                \"name\": \"alice\",\n                \"validator\": true,\n                \"balance\": 1000000000000\n            },\n            {\n                \"name\": \"bob\",\n                \"validator\": true,\n                \"balance\": 1000000000000\n            }\n        ],\n        ...\n    },\n    ...\n}\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#node-group-configuration","title":"Node Group Configuration","text":"<p>The <code>node_groups</code> key is used to define further parameters for the node groups. The available keys are:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (e.g., <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li><code>env?</code> envVars[] - environment variables to set in the container. The <code>envVars</code> interface is defined as follows:   <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre></li> <li><code>overrides?</code> Override[] - array of overrides definitions. The <code>Override</code> interface is defined as follows:   <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre></li> <li><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead. The <code>SubstrateCliArgsVersion</code> enum is defined as follows:   <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre></li> <li><code>resources?</code> Resources - represent the resources limits/reservations needed by the node. The <code>Resources</code> interface is defined as follows:   <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre></li> <li><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</li> <li><code>count</code> number | string - number of nodes to launch for this group</li> <li><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> </ul> <p>The following configuration file defines a minimal example for the relay chain, including the <code>node_groups</code> key:</p> TOMLJSON relaychain-example-node-groups.toml<pre><code>[relaychain]\ndefault_command = \"polkadot\"\ndefault_image = \"polkadot-debug:master\"\nchain = \"rococo-local\"\nchain_spec_path = \"/path/to/chain-spec.json\"\ndefault_args = [\"--chain\", \"rococo-local\"]\n\n[[relaychain.node_groups]]\nname = \"group-1\"\ncount = 2\nimage = \"polkadot-debug:master\"\ncommand = \"polkadot\"\nargs = [\"--chain\", \"rococo-local\"]\n...\n</code></pre> relaychain-example-node-groups.json<pre><code>{\n    ...,\n    \"relaychain\": {\n        \"default_command\": \"polkadot\",\n        \"default_image\": \"polkadot-debug:master\",\n        \"chain\": \"rococo-local\",\n        \"chain_spec_path\": \"/path/to/chain-spec.json\",\n        \"default_args\": [\"--chain\", \"rococo-local\"],\n        \"node_groups\": [\n            {\n                \"name\": \"group-1\",\n                \"count\": 2,\n                \"image\": \"polkadot-debug:master\",\n                \"command\": \"polkadot\",\n                \"args\": [\"--chain\", \"rococo-local\"]\n            }\n        ],\n        ...\n    },\n    ...\n}\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#parachain-configuration","title":"Parachain Configuration","text":"<p>The <code>parachain</code> keyword is used to define further parameters for the parachain. The available keys are:</p> <ul> <li><code>id</code> number - the id to assign to this parachain. Must be unique</li> <li><code>chain?</code> string - the chain name</li> <li><code>force_decorator?</code> string - force the use of a specific decorator</li> <li><code>genesis?</code> JSON - the genesis configuration</li> <li><code>balance?</code> number - balance to set in balances for parachain's account</li> <li><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> <li><code>add_to_genesis?</code> boolean - flag to add parachain to genesis or register in runtime. Defaults to <code>true</code></li> <li><code>register_para?</code> boolean - flag to specify whether the para should be registered. The <code>add_to_genesis</code> flag must be set to false for this flag to have any effect. Defaults to <code>true</code></li> <li><code>onboard_as_parachain?</code> boolean - flag to specify whether the para should be onboarded as a parachain, rather than remaining a parathread. Defaults to <code>true</code></li> <li><code>genesis_wasm_path?</code> string - path to the Wasm file to use</li> <li><code>genesis_wasm_generator?</code> string - command to generate the Wasm file</li> <li><code>genesis_state_path?</code> string - path to the state file to use</li> <li><code>genesis_state_generator?</code> string - command to generate the state file</li> <li><code>chain_spec_path?</code> string - path to the chain spec file</li> <li><code>chain_spec_command?</code> string - command to generate the chain spec</li> <li><code>cumulus_based?</code> boolean - flag to use cumulus command generation. Defaults to <code>true</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>prometheus_prefix?</code> string - parameter for customizing the metric's prefix for all parachain nodes/collators. Defaults to <code>substrate</code></li> <li><code>collator?</code> Collator - further defined on the Collator Configuration section</li> <li><code>collators?</code> Collator[] - an array of collators to spawn. It is further defined on the Collator Configuration section</li> <li><code>collator_groups?</code> CollatorGroup[] - an array of collator groups to spawn. It is further defined on the Collator Groups section</li> </ul> <p>For example, the following configuration file defines a minimal example for the parachain:</p> TOMLJSON parachain-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"/path/to/wasm\"\ngenesis_state_path = \"/path/to/state\"\n...\n</code></pre> parachain-example.json<pre><code>{\n    \"parachain\": {\n      \"id\": 100,\n      \"add_to_genesis\": true,\n      \"cumulus_based\": true,\n      \"genesis_wasm_path\": \"/path/to/wasm\",\n      \"genesis_state_path\": \"/path/to/state\",\n      ...\n    },\n    ...\n}\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#collator-configuration","title":"Collator Configuration","text":"<p>One specific key capable of receiving more subkeys is the <code>collator</code> key. This key is used to define further parameters for the nodes. The available keys are:</p> <ul> <li><code>name</code> string - name of the collator. Any whitespace will be replaced with a dash (e.g., <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - image to use for the collator</li> <li><code>command_with_args?</code> string - overrides both command and arguments for the collator</li> <li><code>validator</code> boolean - pass the <code>--validator</code> flag to the command. Defaults to <code>true</code></li> <li><code>invulnerable</code> boolean - if true, add the collator to invulnerables in the chain spec. Defaults to <code>false</code></li> <li><code>balance</code> number - balance to set in balances for collator's account. Defaults to <code>2000000000000</code></li> <li><code>bootnodes?</code> string[] - array of bootnodes to use</li> <li><code>add_to_bootnodes?</code> boolean - add this collator to the bootnode list. Defaults to <code>false</code></li> <li><code>ws_port?</code> number - WS port to use</li> <li><code>rpc_port?</code> number - RPC port to use</li> <li><code>prometheus_port?</code> number - Prometheus port to use</li> <li><code>p2p_port?</code> number - P2P port to use</li> <li><code>p2p_cert_hash?</code> string - libp2p certhash to use with webRTC transport</li> <li><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> <li><code>command?</code> string - override default command to run</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li><code>env?</code> envVars[] - environment variables to set in the container. The <code>envVars</code> interface is defined as follows:   <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre></li> <li><code>overrides?</code> Override[] - array of overrides definitions. The <code>Override</code> interface is defined as follows:   <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre></li> <li><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead. The <code>SubstrateCliArgsVersion</code> enum is defined as follows:   <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre></li> <li><code>resources?</code> Resources - represent the resources limits/reservations needed by the node. The <code>Resources</code> interface is defined as follows:   <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre></li> <li><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</li> </ul> <p>The configuration file below defines a minimal example for the collator:</p> TOMLJSON collator-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"/path/to/wasm\"\ngenesis_state_path = \"/path/to/state\"\n\n[[parachain.collators]]\nname = \"alice\"\nimage = \"polkadot-parachain\"\ncommand = \"polkadot-parachain\"\n...\n</code></pre> collator-example.json<pre><code>{\n    \"parachain\": {\n      \"id\": 100,\n      \"add_to_genesis\": true,\n      \"cumulus_based\": true,\n      \"genesis_wasm_path\": \"/path/to/wasm\",\n      \"genesis_state_path\": \"/path/to/state\",\n      \"collators\": [\n        {\n          \"name\": \"alice\",\n          \"image\": \"polkadot-parachain\",\n          \"command\": \"polkadot-parachain\",\n          ...\n        },\n      ],\n    },\n    ...\n  }\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#collator-groups","title":"Collator Groups","text":"<p>The <code>collator_groups</code> key is used to define further parameters for the collator groups. The available keys are:</p> <ul> <li><code>name</code> string - name of the node. Any whitespace will be replaced with a dash (e.g., <code>new alice</code> will be converted to <code>new-alice</code>)</li> <li><code>image?</code> string - override default Docker image to use for this node</li> <li><code>command?</code> string - override default command to run</li> <li><code>args?</code> string[] - arguments to be passed to the command</li> <li><code>env?</code> envVars[] - environment variables to set in the container. The <code>envVars</code> interface is defined as follows:   <pre><code>export interface EnvVars {\n  name: string;\n  value: string;\n}\n</code></pre></li> <li><code>overrides?</code> Override[] - array of overrides definitions. The <code>Override</code> interface is defined as follows:   <pre><code>export interface Override {\n  local_path: string;\n  remote_name: string;\n}\n</code></pre></li> <li><code>prometheus_prefix?</code> string - customizes the metric's prefix for the specific node. Defaults to <code>substrate</code></li> <li><code>db_snapshot?</code> string - database snapshot to use</li> <li><code>substrate_cli_args_version?</code> SubstrateCliArgsVersion - set the Substrate CLI arguments version directly to skip binary evaluation overhead. The <code>SubstrateCliArgsVersion</code> enum is defined as follows:   <pre><code>export enum SubstrateCliArgsVersion {\n  V0 = 0,\n  V1 = 1,\n  V2 = 2,\n  V3 = 3,\n}\n</code></pre></li> <li><code>resources?</code> Resources - represent the resources limits/reservations needed by the node. The <code>Resources</code> interface is defined as follows:   <pre><code>export interface Resources {\n  resources: {\n    requests?: {\n      memory?: string;\n      cpu?: string;\n    };\n    limits?: {\n      memory?: string;\n      cpu?: string;\n    };\n  };\n}\n</code></pre></li> <li><code>keystore_key_types?</code> string[] - defines which keystore keys should be created</li> <li><code>count</code> number | string - number of nodes to launch for this group</li> <li><code>delay_network_settings?</code> DelayNetworkSettings - sets the expected configuration to delay the network. The <code>DelayNetworkSettings</code> interface is defined as follows:   <pre><code>export interface DelayNetworkSettings {\n  latency: string;\n  correlation?: string; // should be parsable as float by k8s\n  jitter?: string;\n}\n</code></pre></li> </ul> <p>For instance, the configuration file below defines a minimal example for the collator groups:</p> TOMLJSON collator-groups-example.toml<pre><code>[parachain]\nid = 100\nadd_to_genesis = true\ncumulus_based = true\ngenesis_wasm_path = \"/path/to/wasm\"\ngenesis_state_path = \"/path/to/state\"\n\n[[parachain.collator_groups]]\nname = \"group-1\"\ncount = 2\nimage = \"polkadot-parachain\"\ncommand = \"polkadot-parachain\"\n...\n</code></pre> collator-groups-example.json<pre><code>{\n    \"parachain\": {\n        \"id\": 100,\n        \"add_to_genesis\": true,\n        \"cumulus_based\": true,\n        \"genesis_wasm_path\": \"/path/to/wasm\",\n        \"genesis_state_path\": \"/path/to/state\",\n        \"collator_groups\": [\n            {\n                \"name\": \"group-1\",\n                \"count\": 2,\n                \"image\": \"polkadot-parachain\",\n                \"command\": \"polkadot-parachain\",\n          ...\n            },\n        ],\n    },\n    ...\n}\n</code></pre>"},{"location":"dev-tools/zombienet/overview/#xcm-configuration","title":"XCM Configuration","text":"<p>You can use the <code>hrmp_channels</code> keyword to define further parameters for the XCM channels at start-up. The available keys are:</p> <ul> <li> <p><code>hrmp_channels</code> HrmpChannelsConfig[] - array of Horizontal Relay-routed Message Passing (HRMP) channel configurations. The <code>HrmpChannelsConfig</code> interface is defined as follows:   <pre><code>export interface HrmpChannelsConfig {\n  sender: number;\n  recipient: number;\n  max_capacity: number;\n  max_message_size: number;\n}\n</code></pre> Each of the <code>HrmpChannelsConfig</code> keys are defined as follows:</p> </li> <li> <p><code>sender</code> number - parachain ID of the sender</p> </li> <li><code>recipient</code> number - parachain ID of the recipient</li> <li><code>max_capacity</code> number - maximum capacity of the HRMP channel</li> <li><code>max_message_size</code> number - maximum message size allowed in the HRMP channel</li> </ul>"},{"location":"dev-tools/zombienet/testing/","title":"Testing DSL","text":"<p>Zombienet provides a Domain Specific Language (DSL) for writing tests. The DSL is designed to be human-readable and allows you to write tests using natural language expressions. You can define assertions and tests against the spawned network using this DSL. This way, users can evaluate different metrics, such as:</p> <ul> <li>On-chain storage - the storage of each of the chains running via Zombienet</li> <li>Metrics - the metrics provided by the nodes</li> <li>Histograms - visual representations of metrics data</li> <li>Logs - detailed records of system activities and events</li> <li>System events - notifications of significant occurrences within the network</li> <li>Tracing - detailed analysis of execution paths and operations</li> <li>Custom API calls (through Polkadot.js) - personalized interfaces for interacting with the network</li> <li>Commands - instructions or directives executed by the network</li> </ul> <p>These abstractions are expressed by sentences defined in a natural language style. Therefore, each test line will be mapped to a test to run. Also, the test file (<code>*.zndsl</code>) includes pre-defined header fields used to define information about the suite, such as network configuration and credentials location.</p>"},{"location":"dev-tools/zombienet/testing/#the-test-file","title":"The Test File","text":""},{"location":"dev-tools/zombienet/testing/#name","title":"Name","text":"<p>The test name in Zombienet is derived from the file name by removing any leading numeric characters before the first hyphen. For example, a file named <code>0001-zombienet-test.zndsl</code> will result in a test name of <code>zombienet-test</code>, which will be displayed in the test report output of the runner.</p>"},{"location":"dev-tools/zombienet/testing/#structure","title":"Structure","text":"<p>The test file is a text file with the extension <code>.zndsl</code>. It is divided into two parts: the header and the body. The header contains the network configuration and the credentials to use, while the body contains the tests to run.</p> <p>The header is defined by the following fields:</p> <ul> <li><code>description</code> string - long description of the test suite (optional)</li> <li><code>network</code> string - path to the network definition file, supported in both <code>.json</code> and <code>.toml</code> formats</li> <li><code>creds</code> string - credentials file name or path to use (available only with Kubernetes provider). Looks in the current directory or <code>$HOME/.kube/</code> if a file name is passed</li> </ul> <p>The body contains the tests to run. Each test is defined by a sentence in the DSL, which is mapped to a test to run. Each test line defines an assertion or a command to be executed against the spawned network.</p>"},{"location":"dev-tools/zombienet/testing/#assertions","title":"Assertions","text":"<p>Assertions are defined by sentences in the DSL that evaluate different metrics, such as on-chain storage, metrics, histograms, logs, system events, tracing, and custom API calls. Each assertion is defined by a sentence in the DSL, which is mapped to a test to run.</p> <code>Well known functions</code> - already mapped test function SyntaxExamples <ul> <li><code>node-name well-known_defined_test [within x seconds]</code></li> </ul> <pre><code>alice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n</code></pre> <code>Histogram</code> - get metrics from Prometheus, calculate the histogram and, assert on the target value/s SyntaxExample <ul> <li><code>node-name reports histogram memtric_name has comparator target_value samples in buckets [\"bucket\",\"bucket\",...] [within x seconds]</code></li> </ul> <pre><code>alice: reports histogram polkadot_pvf_execution_time has at least 2 samples in buckets [\"0.1\", \"0.25\", \"0.5\", \"+Inf\"] within 100 seconds\n</code></pre> <code>Metric</code> - get metric from Prometheus and assert on the target value SyntaxExamples <ul> <li><code>node-name reports metric_name comparator target_value (e.g \"is at least x\", \"is greater than x\") [within x seconds]</code></li> </ul> <pre><code>alice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n</code></pre> <code>Log line</code> - get logs from nodes and assert on the matching pattern SyntaxExample <ul> <li><code>node-name log line (contains|matches) (regex|glob) \"pattern\" [within x seconds]</code></li> </ul> <pre><code>alice: log line matches glob \"rted #1\" within 10 seconds\n</code></pre> <code>Count of log lines</code> - get logs from nodes and assert on the number of lines matching pattern SyntaxExample <ul> <li><code>node-name count of log lines (containing|matcheing) (regex|glob) \"pattern\" [within x seconds]</code></li> </ul> <pre><code>alice: count of log lines matching glob \"rted #1\" within 10 seconds\n</code></pre> <code>System events</code> - find a system event from subscription by matching a pattern SyntaxExample <ul> <li><code>node-name system event (contains|matches)(regex| glob) \"pattern\" [within x seconds]</code></li> </ul> <pre><code>alice: system event matches \"\"paraId\":[0-9]+\" within 10 seconds\n</code></pre> <code>Tracing</code> - match an array of span names from the supplied traceID SyntaxExample <ul> <li><code>node-name trace with traceID contains [\"name\", \"name2\",...]</code></li> </ul> <pre><code>alice: trace with traceID 94c1501a78a0d83c498cc92deec264d9 contains [\"answer-chunk-request\", \"answer-chunk-request\"]\n</code></pre> <code>Custom JS scripts</code> - run a custom JS script and assert on the return value SyntaxExample <ul> <li><code>node-name js-script script_relative_path [return is comparator target_value] [within x seconds]</code></li> </ul> <pre><code>alice: js-script ./0008-custom.js return is greater than 1 within 200 seconds\n</code></pre> <code>Custom TS scripts</code> - run a custom TS script and assert on the return value SyntaxExample <ul> <li><code>node-name ts-script script_relative_path [return is comparator target_value] [within x seconds]</code></li> </ul> <pre><code>alice: ts-script ./0008-custom-ts.ts return is greater than 1 within 200 seconds\n</code></pre> <code>Backchannel</code> - wait for a value and register to use SyntaxExample <ul> <li><code>node-name wait for var name and use as X [within x seconds]</code></li> </ul> <pre><code>alice: wait for name and use as X within 30 seconds\n</code></pre>"},{"location":"dev-tools/zombienet/testing/#commands","title":"Commands","text":"<p>Commands allow interaction with the nodes and can run pre-defined commands or an arbitrary command in the node.</p> <code>restart</code> - stop the process and start again after the <code>X</code> amount of seconds or immediately Syntax <ul> <li><code>node-name restart [after x seconds]</code></li> </ul> <code>pause</code> - pause (SIGSTOP) the process Syntax <ul> <li><code>node-name pause</code></li> </ul> <code>resume</code> - resume (SIGCONT) the process Syntax <ul> <li><code>node-name resume</code></li> </ul> <code>sleep</code> - sleep the test-runner for <code>x</code> amount of seconds Syntax <ul> <li><code>sleep x</code></li> </ul>"},{"location":"dev-tools/zombienet/testing/#example","title":"Example","text":"<p>For example, the following test file defines two tests: a small network test and a big network test. Each test defines a network configuration file and credentials to use.</p> <p>The tests define assertions to evaluate the network\u2019s metrics and logs. The assertions are defined by sentences in the DSL, which are mapped to tests to run.</p> <pre><code>Description: Small Network test\nNetwork: ./0000-test-config-small-network.toml\nCreds: config\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\n# logs\nbob: log line matches glob \"*rted #1*\" within 10 seconds\nbob: log line matches \"Imported #[0-9]+\" within 10 seconds\n</code></pre> <p>And the second test file:</p> <pre><code>Description: Big Network test\nNetwork: ./0001-test-config-big-network.toml\nCreds: config\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\n# logs\nbob: log line matches glob \"*rted #1*\" within 10 seconds\nbob: log line matches \"Imported #[0-9]+\" within 10 seconds\n\n# custom js script\nalice: js-script ./0008-custom.js return is greater than 1 within 200 seconds\n\n# custom ts script\nalice: ts-script ./0008-custom-ts.ts return is greater than 1 within 200 seconds\n\n# backchannel\nalice: wait for name and use as X within 30 seconds\n\n# well know functions\nalice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n\n# histogram\nalice: reports histogram polkadot_pvf_execution_time has at least 2 samples in buckets [\"0.1\", \"0.25\", \"0.5\", \"+Inf\"] within 100 seconds\n\n# system events\nalice: system event matches \"\"paraId\":[0-9]+\" within 10 seconds\n\n# tracing\nalice: trace with traceID 94c1501a78a0d83c498cc92deec264d9 contains [\"answer-chunk-request\", \"answer-chunk-request\"]\n</code></pre>"},{"location":"dev-tools/zombienet/testing/#running-tests","title":"Running Tests","text":"<p>To run the tests using the local provider (<code>native</code>), you can use the Zombienet binary. The binary will read the test files and execute the tests defined in the DSL. The binary will output the results of the tests in the console.</p> <pre><code>zombienet -p native test INSERT_TEST_FILE_NAME\n</code></pre> <p>Note</p> <p>Replace <code>INSERT_TEST_FILE_NAME</code> with the path to the test file you want to run.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/","title":"Spawn a Basic Network","text":""},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#introduction","title":"Introduction","text":"<p>In this tutorial, you'll learn how to set up a basic network using Zombienet and run a simple test to validate its functionality. The example provided walks you through defining a minimal network configuration, spawning the network, and interacting with the nodes. By the end, you'll clearly understand how to use Zombienet to deploy and test ephemeral blockchain networks, setting the stage for more complex scenarios.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#prerequisites","title":"Prerequisites","text":"<p>To follow this tutorial, first, you need to have Zombienet installed. If you haven't done so, please follow the instructions in the Installation section.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#defining-the-network","title":"Defining the Network","text":"<p>As mentioned in the Configuration Files section, Zombienet uses a configuration file to define the ephemeral network that will be spawned. To follow this tutorial, create a file named <code>spawn-a-basic-network.toml</code> with the following content:</p> <pre><code>[settings]\ntimeout = 120\n\n[relaychain]\n\n[[relaychain.nodes]]\nname = \"alice\"\nvalidator = true\n\n[[relaychain.nodes]]\nname = \"bob\"\nvalidator = true\n\n[[parachains]]\nid = 100\n\n  [parachains.collator]\n  name = \"collator01\"\n</code></pre> <p>This configuration file defines a network with a relaychain with two nodes, <code>alice</code> and <code>bob</code>, and a parachain with a collator named <code>collator01</code>. Also, it sets a timeout of 120 seconds for the network to be ready.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#running-the-network","title":"Running the Network","text":"<p>To spawn the network, run the following command:</p> <pre><code>zombienet -p native spawn spawn-a-basic-network.toml\n</code></pre> <p>This command will spawn the network defined in the <code>spawn-a-basic-network.toml</code> configuration file. The <code>-p native</code> flag specifies that the network will be spawned using the native provider.</p> <p>If successful, you will see the following output:</p> zombienet -p native spawn spawn-a-basic-network.toml                      Network launched \ud83d\ude80\ud83d\ude80                  Namespace zombie-75a01b93c92d571f6198a67bcb380fcd Provider native                  Node Information                  Name alice Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer Prometheus Link http://127.0.0.1:55310/metrics Log Cmd tail -f /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-2                  Node Information                  Name bob Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55312#explorer Prometheus Link http://127.0.0.1:50634/metrics Log Cmd tail -f /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-2                  Node Information                  Name collator01 Direct Link https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer Prometheus Link http://127.0.0.1:55318/metrics Log Cmd tail -f /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-2 Parachain ID 100 ChainSpec Path /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-2 <p>Note</p> <p>If the IPs and ports are not explicitly defined in the configuration file, they may change each time the network is started, causing the links provided in the output to differ from the example.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#interacting-with-the-spawned-network","title":"Interacting with the Spawned Network","text":""},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#connecting-to-the-nodes","title":"Connecting to the Nodes","text":"<p>After the network is launched, you can interact with it using Polkadot.js Apps. To do so, open your browser and use the provided links listed by the output as <code>Direct Link</code>. For instance, in this particular case, as the ports may vary from spawning to spawning, to interact with the <code>alice</code> node, open https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer as it is the link provided in the output for the <code>alice</code> node. Moreover, you can also do this for the <code>bob</code> and <code>collator01</code> nodes.</p> <p>If you want to interact with the nodes more programmatically, you can also use the Polkadot.js API. For example, the following code snippet shows how to connect to the <code>alice</code> node using the Polkadot.js API and log some information about the chain and node:</p> <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://127.0.0.1:55308');\n    const api = await ApiPromise.create({ provider: wsProvider });\n\n    // Retrieve the chain &amp; node information via rpc calls\n    const [chain, nodeName, nodeVersion] = await Promise.all([\n        api.rpc.system.chain(),\n        api.rpc.system.name(),\n        api.rpc.system.version()\n    ]);\n\n    console.log(`You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`);\n}\n\nmain().catch(console.error).finally(() =&gt; process.exit());\n</code></pre> <p>Either way allows you to interact easily with the network and its nodes.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#checking-metrics","title":"Checking Metrics","text":"<p>You can also check the metrics of the nodes by accessing the provided links listed by the output as <code>Prometheus Link</code>. Prometheus is a monitoring and alerting toolkit that collects metrics from the nodes. By accessing the provided links, you can see the metrics of the nodes in a web interface. So, for example, the following image shows the Prometheus metrics for Bob\u2019s node from the Zombienet test:</p> <p></p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#checking-logs","title":"Checking Logs","text":"<p>To check the nodes\u2019 logs, you can use the provided command listed by the output as 'Log Cmd'. For instance, to check the logs of the <code>alice</code> node, you can open a new terminal and run the following command:</p> <pre><code>tail -f /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-SEzfCidQ1za4/alice.log\n</code></pre> <p>After running this command, you will see the logs of the <code>alice</code> node in real-time, which can be useful for debugging purposes. The logs will be displayed in the terminal in the following format:</p> tail -f /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-75a01b93c92d571f6198a67bcb380fcd_21724-SEzfCidQ1za4/alice.log  2024-08-29 16:03:54 \ud83d\ude4c Starting consensus session on top of parent 0x81bfcf7de46ca0f5c0eca78639dbfa67afa0a22c7f1a98dfc5778449cb0a82f9 2024-08-29 16:03:54 \ud83c\udf81 Prepared block for proposing at 11 (1 ms) [hash: 0x4ae2c654439a9be25cedd03fb9a091a5be7b53eae82276850e8c7061cb656d26; parent_hash: 0x81bf\u202682f9; extrinsics (2): [0x469d\u2026d7d3, 0x8dd2\u202666e8] 2024-08-29 16:03:54 \ud83d\udd16 Pre-sealed block for proposal at 11. Hash now 0xb74014d0fcd6df55fbe42848e21ddb556aa5f7358c66795e9a5131f0a666dbbc, previously 0x4ae2c654439a9be25cedd03fb9a091a5be7b53eae82276850e8c7061cb656d26. 2024-08-29 16:03:54 \ud83d\udc76 New epoch 1 launching at block 0xb740\u2026dbbc (block slot 287493039 &gt;= start slot 287493039). 2024-08-29 16:03:54 \ud83d\udc76 Next epoch starts at slot 287493049 2024-08-29 16:03:54 \ud83c\udfc6 Imported #11 (0x81bf\u202682f9 \u2192 0xb740\u2026dbbc) 2024-08-29 16:03:54 Node uses the following topology indices index_in_gossip_topology=Some(ValidatorIndex(0)) index_in_parachain_authorities=Some(Active(ValidatorIndex(0))) 2024-08-29 16:03:57 \ud83d\udca4 Idle (2 peers), best: #11 (0xb740\u2026dbbc), finalized #8 (0x2282\u20266f0d), \u2b07 2.7kiB/s \u2b06 2.1kiB/s 2024-08-29 16:04:00 \ud83c\udfc6 Imported #12 (0xb740\u2026dbbc \u2192 0x49f4\u2026fbd8) 2024-08-29 16:04:02 \ud83d\udca4 Idle (2 peers), best: #12 (0x49f4\u2026fbd8), finalized #9 (0x470a\u20269184), \u2b07 2.4kiB/s \u2b06 2.1kiB/s 2024-08-29 16:04:06 \ud83d\ude4c Starting consensus session on top of parent 0x49f420d6d1d84031712f8b7535fdcd73fda740e7a1db6c61c4cf35d8aef9fbd8 2024-08-29 16:04:06 \ud83c\udf81 Prepared block for proposing at 13 (5 ms) [hash: 0xd5cb11f7ebc5ece3f9a6c304ab5f6209f1ba148c334efc0844e76dd0815b4ff9; parent_hash: 0x49f4\u2026fbd8; extrinsics (2): [0x9e7c\u202630ff, 0x7e55\u20261806] 2024-08-29 16:04:06 \ud83d\udd16 Pre-sealed block for proposal at 13. Hash now 0xa5022ff182095544d5db8714b2c10d81c75d8aff53c53515f22fcd7220ce97d5, previously 0xd5cb11f7ebc5ece3f9a6c304ab5f6209f1ba148c334efc0844e76dd0815b4ff9. 2024-08-29 16:04:06 \ud83c\udfc6 Imported #13 (0x49f4\u2026fbd8 \u2192 0xa502\u202697d5) 2024-08-29 16:04:06 \u267b\ufe0f Reorg on #13,0xa502\u202697d5 to #13,0xb6c8\u20265c34, common ancestor #12,0x49f4\u2026fbd8 2024-08-29 16:04:06 \ud83c\udfc6 Imported #13 (0x49f4\u2026fbd8 \u2192 0xb6c8\u20265c34) 2024-08-29 16:04:07 \ud83d\udca4 Idle (2 peers), best: #13 (0xb6c8\u20265c34), finalized #10 (0x81bf\u202682f9), \u2b07 4.0kiB/s \u2b06 4.0kiB/s 2024-08-29 16:04:11 \ud83e\udd69 New Rounds for validator set id: 1 with session_start 11 2024-08-29 16:04:11 \ud83e\udd69 Concluded mandatory round #11 2024-08-29 16:04:12 \ud83c\udfc6 Imported #14 (0xb6c8\u20265c34 \u2192 0xb51a\u2026f125) 2024-08-29 16:04:12 \ud83d\udca4 Idle (2 peers), best: #14 (0xb51a\u2026f125), finalized #11 (0xb740\u2026dbbc), \u2b07 2.8kiB/s \u2b06 3.5kiB/s     ...  <p>The logs of the <code>bob</code> and <code>collator01</code> nodes can be checked similarly.</p>"},{"location":"dev-tools/zombienet/tutorials/spawn-a-basic-network/#running-a-test","title":"Running a Test","text":"<p>To run a test against the spawned network, you can use the Zombienet DSL to define the test scenario. For example, you can create a file named <code>spawn-a-basic-network-test.zndsl</code> with the following content:</p> <pre><code>Description: Test the basic functionality of the network (minimal example)\nNetwork: ./spawn-a-basic-network.toml\nCreds: config\n\nalice: is up\nalice: parachain 100 is registered within 225 seconds\nalice: parachain 100 block height is at least 10 within 250 seconds\n\nbob: is up\nbob: parachain 100 is registered within 225 seconds\nbob: parachain 100 block height is at least 10 within 250 seconds\n\n# metrics\nalice: reports node_roles is 4\nalice: reports sub_libp2p_is_major_syncing is 0\n\nbob: reports node_roles is 4\n\ncollator01: reports node_roles is 4\n</code></pre> <p>This test scenario checks to verify the following:</p> <ul> <li>the nodes are running</li> <li>the parachain with ID 100 is registered within a certain timeframe (255 seconds in this example)</li> <li>the parachain block height is at least a certain number within a timeframe (in this case, 10 within 255 seconds)</li> <li>the nodes report metrics </li> </ul> <p>However, you can define any test scenario following the Zombienet DSL syntax.</p> <p>To run the test, execute the following command:</p> <pre><code>zombienet -p native test spawn-a-basic-network-test.zndsl\n</code></pre> <p>This command will execute the test scenario defined in the <code>spawn-a-basic-network-test.zndsl</code> file on the network. If successful, the terminal will display the test output, indicating whether the test passed or failed. For example, the following output shows the test results for the basic network:</p> \ud83d\udece\ufe0f Tests are currently running. Results will appear at the end Test Results 8/29/2024, 4:34:53 PM \u2705 alice: is up (104ms) 2024-08-29 16:34:54 API/INIT: RPC methods not decorated: chainHead_v1_body, chainHead_v1_call, chainHead_v1_continue, chainHead_v1_follow, chainHead_v1_header, chainHead_v1_stopOperation, chainHead_v1_storage, chainHead_v1_unfollow, chainHead_v1_unpin, chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties, transactionWatch_v1_submitAndWatch, transactionWatch_v1_unwatch, transaction_v1_broadcast, transaction_v1_stop 2024-08-29 16:34:54 API/INIT: rococo/1014000: Not decorating unknown runtime apis: 0x6ff52ee858e6c5bd/1, 0x91b1c8b16328eb92/1, 0x9ffb505aa738d69c/1 8/29/2024, 4:34:56 PM \u2705 alice: parachain 100 is registered within 225 seconds (2362ms) 8/29/2024, 4:34:58 PM \u2705 alice: parachain 100 block height is at least 10 within 250 seconds (2037ms) 8/29/2024, 4:34:58 PM \u2705 bob: is up (43ms) 2024-08-29 16:34:58 API/INIT: RPC methods not decorated: chainHead_v1_body, chainHead_v1_call, chainHead_v1_continue, chainHead_v1_follow, chainHead_v1_header, chainHead_v1_stopOperation, chainHead_v1_storage, chainHead_v1_unfollow, chainHead_v1_unpin, chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties, transactionWatch_v1_submitAndWatch, transactionWatch_v1_unwatch, transaction_v1_broadcast, transaction_v1_stop 2024-08-29 16:34:58 API/INIT: rococo/1014000: Not decorating unknown runtime apis: 0x6ff52ee858e6c5bd/1, 0x91b1c8b16328eb92/1, 0x9ffb505aa738d69c/1 8/29/2024, 4:35:00 PM \u2705 bob: parachain 100 is registered within 225 seconds (2206ms) 8/29/2024, 4:35:02 PM \u2705 bob: parachain 100 block height is at least 10 within 250 seconds (2037ms) 8/29/2024, 4:35:02 PM \u2705 alice: reports node_roles is 4 (0ms) 8/29/2024, 4:35:02 PM \u2705 alice: reports sub_libp2p_is_major_syncing is 0 (0ms) 8/29/2024, 4:35:02 PM \u2705 bob: reports node_roles is 4 (1ms) 8/29/2024, 4:35:02 PM \u2705 collator01: reports node_roles is 4 (22ms) \ud83d\udcd3 To see the full logs of the nodes please go to: /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/zombie-68b7ea2539c6ce9ad6350d8a88674147_-90400-wSMnGnsj9Gnu/logs Result: 10/10 exit code 0"},{"location":"networks/testnets/paseo-testnet/onboarding/","title":"Deploying a Parachain on Paseo TestNet","text":""},{"location":"networks/testnets/paseo-testnet/onboarding/#introduction","title":"Introduction","text":"<p>Paseo is a community-run TestNet designed for parachain teams and dApp developers to build and test their solutions. The Paseo network is open, allowing anyone to launch a parachain as part of their process for eventual deployment onto the Polkadot MainNet.</p> <p>This project is maintained by the members of the following teams: Portico, R0GUE, and Zondax. For further support, you can reach out to the team members on the Paseo Matrix channel.</p> <p>It provides dedicated parachain slots to maintainers, with the lease period duration varying based on the following criteria:</p> <ul> <li> <p>Maintainers of live parachains on the Polkadot or Kusama MainNets will be granted a dedicated Paseo parachain slot for a one-year lease period</p> </li> <li> <p>Maintainers of parachains under active development, or those that have not yet secured a parachain slot on Kusama or Polkadot, will be assigned a shorter Paseo lease period of two weeks</p> </li> </ul> <p>This guide will walk you through deploying your blockchain as a parachain on the Paseo TestNet. It covers generating a customized chain spec, securing a dedicated parachain slot, and setting up and running your parachain.</p>"},{"location":"networks/testnets/paseo-testnet/onboarding/#prerequisites","title":"Prerequisites","text":"<p>Before you can deploy your parachain on the Paseo TestNet, you'll need to meet the following requirements:</p> <ul> <li>Parachain Runtime - a fully operational blockchain capable of operating as a parachain</li> </ul>"},{"location":"networks/testnets/paseo-testnet/onboarding/#select-a-parachain-id","title":"Select a Parachain ID","text":"<p>To deploy your parachain, you'll first need to select a unique parachain ID on the Paseo TestNet:</p> <ol> <li> <p>Visit Polkadot.js Apps and ensure you're connected to the Paseo TestNet</p> </li> <li> <p>Navigate to the Network dropdown, then select the Parachains option from the menu that appears     </p> </li> <li> <p>Review the list of active parachains and parathreads, and select an available parachain ID for your chain. Ensure the ID you choose is not currently used by examining:</p> <ul> <li> <p>The parachains column   </p> </li> <li> <p>The parathreads column under the Parathreads tab   </p> </li> </ul> </li> </ol>"},{"location":"networks/testnets/paseo-testnet/onboarding/#generate-customs-keys-for-your-collators","title":"Generate Customs Keys for Your Collators","text":"<p>To securely deploy your parachain, it is essential to generate custom keys specifically for your collators (block producers). You should generate two sets of keys for each collator:</p> <ul> <li> <p>Account keys - used to interact with the network and manage funds. These should be protected carefully and should never exist on the filesystem of the collator node</p> </li> <li> <p>Session keys - used in block production. These identify your node and its blocks on the network. Stored in the parachain keystore, these are disposable \"hot wallet\" keys. If leaked, they could be used to impersonate your node, potentially leading to fund slashing. To mitigate risks, rotate these keys frequently. Treat them with the same caution as a hot wallet to protect your node security</p> </li> </ul> <p>To perform this step, you can use subkey, a command-line tool for generating and managing keys:</p> <pre><code>docker run -it parity/subkey:latest generate --scheme sr25519\n</code></pre> <p>Note</p> <p>Several methods can be used to generate your keys. This tutorial opts for using the subkey Docker image for simplicity.</p> <p>The output should look similar to the following:</p> docker run -it parity/subkey:latest generate --scheme sr25519 Secret phrase: lemon play remain picture leopard frog mad bridge hire hazard best buddy   Network ID: substrate   Secret seed: 0xb748b501de061bae1fcab1c0b814255979d74d9637b84e06414a57a1a149c004   Public key (hex): 0xf4ec62ec6e70a3c0f8dcbe0531e2b1b8916cf16d30635bbe9232f6ed3f0bf422   Account ID: 0xf4ec62ec6e70a3c0f8dcbe0531e2b1b8916cf16d30635bbe9232f6ed3f0bf422   Public key (SS58): 5HbqmBBJ5ALUzho7tw1k1jEgKBJM7dNsQwrtfSfUskT1a3oe   SS58 Address: 5HbqmBBJ5ALUzho7tw1k1jEgKBJM7dNsQwrtfSfUskT1a3oe  <p>Ensure that this command is executed twice to generate the keys for both the account and session keys. Save them for future reference.</p>"},{"location":"networks/testnets/paseo-testnet/onboarding/#generate-and-customize-the-chain-spec","title":"Generate and Customize the Chain Spec","text":"<p>Substrate-based blockchains are defined by a file called the chain specification, or chain spec for short. This guide explains how to use a template provided by OpenZeppelin's Substrate Parachain Runtimes to create and modify the chain spec file. Although most of the time you will use your custom runtime, the steps outlined here can be adapted to your specific runtime with minor adjustments.</p> <p>There are two types of chain spec files:</p> <ul> <li>Plain chain spec - a human-readable JSON file that can be modified to suit your parachain's requirements. It serves as a template for initial configuration and includes human-readable keys and structures</li> <li>Raw chain spec - a binary-encoded file used to start your parachain node. This file is generated from the plain chain spec and contains the encoded information necessary for the parachain node to synchronize with the blockchain network. It ensures compatibility across different runtime versions by providing data in a format directly interpretable by the node's runtime, regardless of upgrades since the chain's genesis</li> </ul> <p>Before starting, clone the repository and execute the build command:</p> <pre><code>git clone -b vv1.0.0 https://github.com/OpenZeppelin/polkadot-runtime-templates.git\ncd polkadot-runtime-templates\ncargo build --release\n</code></pre> <p>Note</p> <p>The <code>cargo build --release</code> command will take a considerable amount of time to complete, depending on your system's specifications. This is normal for Substrate-based projects due to their complexity.</p> <ol> <li> <p>Generate a plain chain spec:</p> <pre><code>./target/release/parachain-template-node build-spec \\\n--disable-default-bootnode &gt; plain-parachain-chainspec.json\n</code></pre> </li> <li> <p>Edit the <code>plain-parachain-chainspec.json</code> file:</p> <ul> <li>Update the <code>name</code>, <code>id</code> and <code>protocolId</code> fields to unique values for your parachain</li> <li>Change the <code>relay_chain</code> field to <code>paseo</code></li> <li>Change <code>para_id</code> and <code>parachainInfo.parachainId</code> from 1000 to the parachain ID you selected in the Select a Parachain ID step</li> <li>Insert the account IDs and session keys in SS58 format generated for your collators in the <code>collatorSelection.invulnerables</code> and <code>session.keys</code> fields</li> <li>Modify the <code>sudo</code> value to specify the account that will have sudo access to the parachain</li> </ul> <pre><code>{\n  \"name\": \"INSERT_NAME\",\n  \"id\": \"INSERT_ID\",\n  \"chainType\": \"Local\",\n  \"bootNodes\": [],\n  \"telemetryEndpoints\": null,\n  \"protocolId\": \"INSERT_PROTOCOL_ID\",\n  \"properties\": {\n    \"ss58Format\": 42,\n    \"tokenDecimals\": 12,\n    \"tokenSymbol\": \"UNIT\"\n  },\n  \"relay_chain\": \"paseo\",\n  \"para_id\": 1,\n  \"codeSubstitutes\": {},\n  \"genesis\": {\n    \"runtimeGenesis\": {\n      \"code\": \"...\",\n      \"patch\": {\n        \"balances\": {},\n        \"collatorSelection\": {\n          \"candidacyBond\": 16000000000,\n          \"invulnerables\": [\n            \"INSERT_ACCOUNT_ID_COLLATOR_1\",\n            \"INSERT_ACCOUNT_ID_COLLATOR_2\"\n          ]\n        },\n        \"parachainInfo\": {\n          \"parachainId\": 1\n        },\n        \"polkadotXcm\": {\n          \"safeXcmVersion\": 4\n        },\n        \"session\": {\n          \"keys\": [\n            [\n              \"INSERT_ACCOUNT_ID_COLLATOR_1\",\n              \"INSERT_ACCOUNT_ID_COLLATOR_1\",\n              {\n                \"aura\": \"INSERT_SESSION_KEY_COLLATOR_1\"\n              }\n            ],\n            [\n              \"INSERT_ACCOUNT_ID_COLLATOR_2\",\n              \"INSERT_ACCOUNT_ID_COLLATOR_2\",\n              {\n                \"aura\": \"INSERT_SESSION_KEY_COLLATOR_2\"\n              }\n            ]\n          ]\n        },\n        \"sudo\": {\n          \"key\": \"INSERT_SUDO_ACCOUNT\"\n        }\n      }\n    }\n  }\n}\n</code></pre> </li> <li> <p>Generate a raw chain spec:</p> <pre><code>./target/release/parachain-template-node build-spec --chain plain-parachain-chainspec.json \\\n--disable-default-bootnode --raw &gt; raw-parachain-chainspec.json\n</code></pre> </li> </ol>"},{"location":"networks/testnets/paseo-testnet/onboarding/#obtain-a-parachain-slot","title":"Obtain a Parachain Slot","text":"<p>Before securing a dedicated parachain slot, you'll need to generate the following files:</p> <ul> <li>Genesis state - the initial state of your parachain</li> <li>Genesis Wasm - the initial runtime Wasm blob of your parachain</li> </ul> <p>Note</p> <p>Replace <code>&lt;INSERT_SELECTED_PARA_ID&gt;</code> with the actual parachain ID you reserved earlier when executing the following commands:</p> <ol> <li> <p>Generate a genesis state:</p> <pre><code>./target/release/parachain-template-node export-genesis-state \\\n--chain raw-parachain-chainspec.json para-&lt;INSERT_SELECTED_PARA_ID&gt;-genesis-state\n</code></pre> </li> <li> <p>Generate a genesis Wasm:</p> <pre><code>./target/release/parachain-template-node export-genesis-wasm \\\n--chain raw-parachain-chainspec.json para-&lt;INSERT_SELECTED_PARA_ID&gt;-wasm\n</code></pre> </li> <li> <p>Create an issue in the Paseo support repository using the Paseo Parachain Onboarding issue template</p> <p></p> </li> <li> <p>Ensure you fill in all the necessary information, including your parachain name, selected parachain ID, manager account, genesis state, and genesis Wasm files from the previous steps. After filling in the required details, submit the issue     </p> </li> <li> <p>Once your request is reviewed and approved, you'll be allocated a dedicated parachain slot</p> </li> </ol>"},{"location":"networks/testnets/paseo-testnet/onboarding/#set-up-your-parachain","title":"Set Up Your Parachain","text":"<p>With a parachain slot secured, you can now set up and run your parachain on the Paseo TestNet.</p> <ol> <li> <p>Download the Paseo Network raw chain spec file</p> </li> <li> <p>Start your parachain collator node by running the command with the appropriate flags and options for your setup. For example:</p> <pre><code>./target/release/parachain-template-node \\\n--collator \\\n--force-authoring \\\n--chain raw-parachain-chainspec.json \\\n--base-path ./data \\\n--port 40333 \\\n--rpc-port 8845 \\\n-- \\\n--sync warp \\\n--execution wasm \\\n--chain paseo.raw.json \\\n--port 30343 \\\n--rpc-port 9977\n</code></pre> <p>Note</p> <p>The following arguments are mandatory for running your parachain node:</p> <ul> <li><code>--collator</code> - configures the node to work as a parachain collator</li> <li><code>--force-authoring</code> - ensures the node produces blocks even when operating as a single node without peers</li> <li><code>--chain</code> - specifies the chain specification file for your parachain</li> <li><code>--</code> - separates parachain and relay chain arguments</li> <li><code>--sync warp</code> - argument is optional, but highly recommended. Without this, the default is full sync, which can take a significantly longer time</li> <li><code>--chain</code> - indicates which relay chain to connect to and synchronize with</li> </ul> <p>For more information on the available command-line arguments you can provide to your collator node, execute the following command:</p> <pre><code>./target/release/parachain-template-node -h\n</code></pre> </li> <li> <p>Insert the session key previously generated in your collator keystore by running the following command with the appropriate values:</p> <pre><code>curl -H \"Content-Type: application/json\" \\\n--data '{\n  \"jsonrpc\":\"2.0\",\n  \"method\":\"author_insertKey\",\n  \"params\":[\n    \"aura\",\n    \"INSERT_SECRET_PHRASE\",\n    \"INSERT_PUBLIC_KEY_HEX_FORMAT\"\n  ],\n  \"id\":1\n}' \\\nhttp://localhost:8845\n</code></pre> <p>If successful, you should see the following response:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"result\":null,\"id\":1}\n</code></pre> <p>Note</p> <p>Replace the port number <code>8845</code> with the RPC port you specified when starting your collator node. Also, replace <code>INSERT_SECRET_PHRASE</code> and <code>INSERT_PUBLIC_KEY_HEX_FORMAT</code> with the session key generated for your collator.</p> </li> <li> <p>Once your collator is synced with the Paseo relay chain, it will begin producing blocks for your parachain. This process may take some time. You'll see log messages indicating when your parachain starts participating in block production</p> </li> </ol> <p>Congratulations! You've successfully deployed your parachain on the Paseo TestNet. You can now test and iterate on your blockchain project within the Paseo ecosystem.</p>"}]}